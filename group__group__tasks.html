<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libcgroup: 4. Manipulation with tasks</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libcgroup
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle"><div class="title">4. Manipulation with tasks</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Simple task assignment</h2></td></tr>
<tr><td class="ititle" colspan="2"><p ><a class="anchor" id="amgrp97ba257d9453e92bab382c7df8d94b24"></a>Applications can use following functions to simply put a task into given control group and find a groups where given tasks is. </p>
</td></tr>
<tr class="memitem:ga43414ac2b1fc73bbb46b6278c7500188"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tasks.html#ga43414ac2b1fc73bbb46b6278c7500188">cgroup_attach_task</a> (struct <a class="el" href="structcgroup.html">cgroup</a> *<a class="el" href="structcgroup.html">cgroup</a>)</td></tr>
<tr class="separator:ga43414ac2b1fc73bbb46b6278c7500188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c7532681986d156ac3f6bac1fcf6aab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tasks.html#ga9c7532681986d156ac3f6bac1fcf6aab">cgroup_attach_task_pid</a> (struct <a class="el" href="structcgroup.html">cgroup</a> *<a class="el" href="structcgroup.html">cgroup</a>, pid_t tid)</td></tr>
<tr class="separator:ga9c7532681986d156ac3f6bac1fcf6aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d4677baef780c003fc6fba6b5dc78f2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tasks.html#ga2d4677baef780c003fc6fba6b5dc78f2">cgroup_change_cgroup_path</a> (const char *path, pid_t pid, const char *const controllers[])</td></tr>
<tr class="separator:ga2d4677baef780c003fc6fba6b5dc78f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f2c17b99cf2526cb46df4769eb3f46e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tasks.html#ga6f2c17b99cf2526cb46df4769eb3f46e">cgroup_get_current_controller_path</a> (pid_t pid, const char *controller, char **current_path)</td></tr>
<tr class="separator:ga6f2c17b99cf2526cb46df4769eb3f46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Rules</h2></td></tr>
<tr><td class="ititle" colspan="2"><p ><a class="anchor" id="amgrp1f4da964f8eab62e96e8cfe406e44364"></a><code>libcgroup</code> can move tasks to control groups using simple rules, loaded from configuration file. See cgrules.conf man page to see format of the file. Following functions can be used to load these rules from a file. </p>
</td></tr>
<tr class="memitem:gad7fa5a2c4db08d31da5bfbecaf482d3d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tasks.html#gad7fa5a2c4db08d31da5bfbecaf482d3d">cgroup_init_rules_cache</a> (void)</td></tr>
<tr class="separator:gad7fa5a2c4db08d31da5bfbecaf482d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf81ebd9cb5575c75b4c85f385ebda1ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tasks.html#gaf81ebd9cb5575c75b4c85f385ebda1ce">cgroup_reload_cached_rules</a> (void)</td></tr>
<tr class="separator:gaf81ebd9cb5575c75b4c85f385ebda1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4e3f29cfbdc3d77f08c9fe60857274a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tasks.html#gac4e3f29cfbdc3d77f08c9fe60857274a">cgroup_print_rules_config</a> (FILE *fp)</td></tr>
<tr class="separator:gac4e3f29cfbdc3d77f08c9fe60857274a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Rule based task assignment</h2></td></tr>
<tr><td class="ititle" colspan="2"><p ><a class="anchor" id="amgrp40f06dbe04f1172d30d928c8f15ab1a1"></a><code>libcgroup</code> can move tasks to control groups using simple rules, loaded from configuration file. See cgrules.conf man page to see format of the file. Applications can move tasks to control groups based on these rules using following functions. </p>
</td></tr>
<tr class="memitem:gafc69658b012b6f1c11ba078ffccd70a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tasks.html#gafc69658b012b6f1c11ba078ffccd70a2">cgroup_change_all_cgroups</a> (void)</td></tr>
<tr class="separator:gafc69658b012b6f1c11ba078ffccd70a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga368e7b8e19b3943ab6fb50e76a09e6ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tasks.html#ga368e7b8e19b3943ab6fb50e76a09e6ea">cgroup_change_cgroup_flags</a> (uid_t uid, gid_t gid, const char *procname, pid_t pid, int flags)</td></tr>
<tr class="separator:ga368e7b8e19b3943ab6fb50e76a09e6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae472183a7c9a37826ef15c77014c47fb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tasks.html#gae472183a7c9a37826ef15c77014c47fb">cgroup_change_cgroup_uid_gid_flags</a> (uid_t uid, gid_t gid, pid_t pid, int flags)</td></tr>
<tr class="separator:gae472183a7c9a37826ef15c77014c47fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5eab78a922dbacd368360f03c70146be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tasks.html#ga5eab78a922dbacd368360f03c70146be">cgroup_change_cgroup_uid_gid</a> (uid_t uid, gid_t gid, pid_t pid)</td></tr>
<tr class="separator:ga5eab78a922dbacd368360f03c70146be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Communication with cgrulesengd daemon</h2></td></tr>
<tr><td class="ititle" colspan="2"><p ><a class="anchor" id="amgrpe4f83f250bc6912276cdf33ed1694119"></a>Users can use cgrulesengd daemon to move tasks to groups based on the rules automatically when they change their UID, GID or executable name. The daemon allows tasks to be 'sticky', i.e. all rules are ignored for these tasks and the daemon never moves them. </p>
</td></tr>
<tr class="memitem:ga64f7967d6d5edfff9afddaa6a6974b1c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tasks.html#ga64f7967d6d5edfff9afddaa6a6974b1c">cgroup_register_unchanged_process</a> (pid_t pid, int flags)</td></tr>
<tr class="separator:ga64f7967d6d5edfff9afddaa6a6974b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga43414ac2b1fc73bbb46b6278c7500188" name="ga43414ac2b1fc73bbb46b6278c7500188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43414ac2b1fc73bbb46b6278c7500188">&#9670;&nbsp;</a></span>cgroup_attach_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_attach_task </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup.html">cgroup</a> *&#160;</td>
          <td class="paramname"><em>cgroup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Move current task (=thread) to given control group. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cgroup</td><td>Destination control group.</td></tr>
  </table>
  </dd>
</dl>
<p>cgroup_attach_task is used to attach the current thread to a cgroup. struct cgroup *cgroup: The cgroup to assign the current thread to.</p>
<p >See cg_attach_task_pid for return values. </p>

</div>
</div>
<a id="ga9c7532681986d156ac3f6bac1fcf6aab" name="ga9c7532681986d156ac3f6bac1fcf6aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c7532681986d156ac3f6bac1fcf6aab">&#9670;&nbsp;</a></span>cgroup_attach_task_pid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_attach_task_pid </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup.html">cgroup</a> *&#160;</td>
          <td class="paramname"><em>cgroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pid_t&#160;</td>
          <td class="paramname"><em>tid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Move given task (=thread) to given control group. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cgroup</td><td>Destination control group. </td></tr>
    <tr><td class="paramname">tid</td><td>The task to move.</td></tr>
  </table>
  </dd>
</dl>
<p>cgroup_attach_task_pid is used to assign tasks to a cgroup. struct cgroup *cgroup: The cgroup to assign the thread to. pid_t tid: The thread to be assigned to the cgroup.</p>
<p >returns 0 on success. returns ECGROUPNOTOWNER if the caller does not have access to the cgroup. returns ECGROUPNOTALLOWED for other causes of failure. </p>

</div>
</div>
<a id="gafc69658b012b6f1c11ba078ffccd70a2" name="gafc69658b012b6f1c11ba078ffccd70a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc69658b012b6f1c11ba078ffccd70a2">&#9670;&nbsp;</a></span>cgroup_change_all_cgroups()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_change_all_cgroups </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Changes the cgroup of all running PIDs based on the rules in the config file. If a rules exists for a PID, then the PID is placed in the correct group.</p>
<p >This function may be called after creating new control groups to move running PIDs into the newly created control groups. </p><dl class="section return"><dt>Returns</dt><dd>0 on success, &lt; 0 on error </dd></dl>

</div>
</div>
<a id="ga368e7b8e19b3943ab6fb50e76a09e6ea" name="ga368e7b8e19b3943ab6fb50e76a09e6ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga368e7b8e19b3943ab6fb50e76a09e6ea">&#9670;&nbsp;</a></span>cgroup_change_cgroup_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_change_cgroup_flags </td>
          <td>(</td>
          <td class="paramtype">uid_t&#160;</td>
          <td class="paramname"><em>uid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gid_t&#160;</td>
          <td class="paramname"><em>gid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>procname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pid_t&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Changes the cgroup of a program based on the rules in the config file. If a rule exists for the given UID, GID or PROCESS NAME, then the given PID is placed into the correct group. By default, this function parses the configuration file each time it is called.</p>
<p >The flags can alter the behavior of this function: CGFLAG_USECACHE: Use cached rules instead of parsing the config file CGFLAG_USE_TEMPLATE_CACHE: Use cached templates instead of parsing the config file</p>
<p >This function may NOT be thread safe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uid</td><td>The UID to match. </td></tr>
    <tr><td class="paramname">gid</td><td>The GID to match. </td></tr>
    <tr><td class="paramname">procname</td><td>The PROCESS NAME to match. </td></tr>
    <tr><td class="paramname">pid</td><td>The PID of the process to move. </td></tr>
    <tr><td class="paramname">flags</td><td>Bit flags to change the behavior, as defined in enum #cgflags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000016">Todo:</a></b></dt><dd>Determine thread-safeness and fix of not safe. </dd></dl>

</div>
</div>
<a id="ga2d4677baef780c003fc6fba6b5dc78f2" name="ga2d4677baef780c003fc6fba6b5dc78f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d4677baef780c003fc6fba6b5dc78f2">&#9670;&nbsp;</a></span>cgroup_change_cgroup_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_change_cgroup_path </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pid_t&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>controllers</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Changes the cgroup of a task based on the path provided. In this case, the user must already know into which cgroup the task should be placed and no rules will be parsed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Name of the destination group. </td></tr>
    <tr><td class="paramname">pid</td><td>The task to move. </td></tr>
    <tr><td class="paramname">controllers</td><td>List of controllers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo:</a></b></dt><dd>should this function be really public? </dd></dl>
<p >Changes the cgroup of a program based on the path provided. In this case, the user must already know into which cgroup the task should be placed and no rules will be parsed.</p>
<p >returns 0 on success. </p>

</div>
</div>
<a id="ga5eab78a922dbacd368360f03c70146be" name="ga5eab78a922dbacd368360f03c70146be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5eab78a922dbacd368360f03c70146be">&#9670;&nbsp;</a></span>cgroup_change_cgroup_uid_gid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_change_cgroup_uid_gid </td>
          <td>(</td>
          <td class="paramtype">uid_t&#160;</td>
          <td class="paramname"><em>uid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gid_t&#160;</td>
          <td class="paramname"><em>gid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pid_t&#160;</td>
          <td class="paramname"><em>pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Provides backwards-compatibility with older versions of the API. This function is deprecated, and <a class="el" href="group__group__tasks.html#gae472183a7c9a37826ef15c77014c47fb">cgroup_change_cgroup_uid_gid_flags()</a> should be used instead. In fact, this function simply calls the newer one with flags set to 0 (none). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uid</td><td>The UID to match. </td></tr>
    <tr><td class="paramname">gid</td><td>The GID to match. </td></tr>
    <tr><td class="paramname">pid</td><td>The PID of the process to move.</td></tr>
  </table>
  </dd>
</dl>
<p>Provides backwards-compatibility with older versions of the API. This function is deprecated, and <a class="el" href="group__group__tasks.html#gae472183a7c9a37826ef15c77014c47fb">cgroup_change_cgroup_uid_gid_flags()</a> should be used instead. In fact, this function simply calls the newer one with flags set to 0 (none). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uid</td><td>The UID to match </td></tr>
    <tr><td class="paramname">gid</td><td>The GID to match </td></tr>
    <tr><td class="paramname">pid</td><td>The PID of the process to move </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, &gt; 0 on error </dd></dl>

</div>
</div>
<a id="gae472183a7c9a37826ef15c77014c47fb" name="gae472183a7c9a37826ef15c77014c47fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae472183a7c9a37826ef15c77014c47fb">&#9670;&nbsp;</a></span>cgroup_change_cgroup_uid_gid_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_change_cgroup_uid_gid_flags </td>
          <td>(</td>
          <td class="paramtype">uid_t&#160;</td>
          <td class="paramname"><em>uid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gid_t&#160;</td>
          <td class="paramname"><em>gid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pid_t&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Changes the cgroup of a program based on the rules in the config file. If a rule exists for the given UID or GID, then the given PID is placed into the correct group. By default, this function parses the configuration file each time it is called.</p>
<p >This function may NOT be thread safe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uid</td><td>The UID to match. </td></tr>
    <tr><td class="paramname">gid</td><td>The GID to match. </td></tr>
    <tr><td class="paramname">pid</td><td>The PID of the process to move. </td></tr>
    <tr><td class="paramname">flags</td><td>Bit flags to change the behavior, as defined in enum #cgflags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000017">Todo:</a></b></dt><dd>Determine thread-safeness and fix if not safe. </dd></dl>

</div>
</div>
<a id="ga6f2c17b99cf2526cb46df4769eb3f46e" name="ga6f2c17b99cf2526cb46df4769eb3f46e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f2c17b99cf2526cb46df4769eb3f46e">&#9670;&nbsp;</a></span>cgroup_get_current_controller_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_get_current_controller_path </td>
          <td>(</td>
          <td class="paramtype">pid_t&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>controller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>current_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the current control group path where the given task is. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pid</td><td>The task to find. </td></tr>
    <tr><td class="paramname">controller</td><td>The controller (hierarchy), where to find the task. </td></tr>
    <tr><td class="paramname">current_path</td><td>The path to control group, where the task has been found. The patch is relative to the root of the hierarchy. The caller must free this memory.</td></tr>
  </table>
  </dd>
</dl>
<p>cgroup_get_current_controller_path @pid: pid of the current process for which the path is to be determined @controller: name of the controller for which to determine current path @current_path: a pointer that is filled with the value of the current path as seen in /proc/&lt;pid&gt;/cgroup </p>

</div>
</div>
<a id="gad7fa5a2c4db08d31da5bfbecaf482d3d" name="gad7fa5a2c4db08d31da5bfbecaf482d3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7fa5a2c4db08d31da5bfbecaf482d3d">&#9670;&nbsp;</a></span>cgroup_init_rules_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_init_rules_cache </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Initializes the rules cache and load it from /etc/cgrules.conf. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000015">Todo:</a></b></dt><dd>add parameter with the filename? </dd></dl>
<p >Initializes the rules cache. </p><dl class="section return"><dt>Returns</dt><dd>0 on success, &gt; 0 on error </dd></dl>

</div>
</div>
<a id="gac4e3f29cfbdc3d77f08c9fe60857274a" name="gac4e3f29cfbdc3d77f08c9fe60857274a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4e3f29cfbdc3d77f08c9fe60857274a">&#9670;&nbsp;</a></span>cgroup_print_rules_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgroup_print_rules_config </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Print the cached rules table. This function should be called only after first calling cgroup_parse_config(), but it will work with an empty rule list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>Destination file, where the rules will be printed.</td></tr>
  </table>
  </dd>
</dl>
<p>Print the cached rules table. This function should be called only after first calling cgroup_parse_config(), but it will work with an empty rule list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>The file stream to print to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga64f7967d6d5edfff9afddaa6a6974b1c" name="ga64f7967d6d5edfff9afddaa6a6974b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64f7967d6d5edfff9afddaa6a6974b1c">&#9670;&nbsp;</a></span>cgroup_register_unchanged_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_register_unchanged_process </td>
          <td>(</td>
          <td class="paramtype">pid_t&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Register the unchanged process to a cgrulesengd daemon. This process is never moved to another control group by the daemon. If the daemon does not work, this function returns 0 as success. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pid</td><td>The task id. </td></tr>
    <tr><td class="paramname">flags</td><td>Bit flags to change the behavior, as defined in #cgroup_daemon_type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf81ebd9cb5575c75b4c85f385ebda1ce" name="gaf81ebd9cb5575c75b4c85f385ebda1ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf81ebd9cb5575c75b4c85f385ebda1ce">&#9670;&nbsp;</a></span>cgroup_reload_cached_rules()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_reload_cached_rules </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reloads the rules list from /etc/cgrules.conf. This function is probably NOT thread safe (calls cgroup_parse_rules_config()).</p>
<p >Reloads the rules list, using the given configuration file. This function is probably NOT thread safe (calls cgroup_parse_rules()). </p><dl class="section return"><dt>Returns</dt><dd>0 on success, &gt; 0 on failure </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
