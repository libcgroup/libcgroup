<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libcgroup: 2. Group manipulation API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libcgroup
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle"><div class="title">2. Group manipulation API</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgroup.html">cgroup</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgroup__controller.html">cgroup_controller</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Basic infrastructure</h2></td></tr>
<tr><td class="ititle" colspan="2"><p ><code>struct cgroup*</code> is the heart of <code>libcgroup</code> API. The structure is opaque to applications, all access to the structure is through appropriate functions.</p>
<p >The most important information is that <b> one <code>struct cgroup*</code> can represent zero, one or more real control groups in kernel</b>. The <code>struct cgroup*</code> is identified by name of the group, which must be set by <a class="el" href="group__group__groups.html#gad34c82ead174988d418f3dcb003aaca7">cgroup_new_cgroup()</a>. Multiple controllers (aka subsystems) can be attached to one <code>struct cgroup*</code> using <a class="el" href="group__group__groups.html#ga3929afd6ced9fe877613286b5f06cf8d">cgroup_add_controller()</a>. These controllers <b>can belong to different hierarchies</b>.</p>
<p >This approach is different to the one in the Linux kernel - a control group must be part of exactly one hierarchy there. In <code>libcgroup</code>, a group can be part of multiple hierarchies, as long as the group name is the same.</p>
<dl class="section user"><dt>Example:</dt><dd>Let there be following control groups: <div class="fragment"><div class="line">cpu,cpuacct:/</div>
<div class="line">cpu,cpuacct:/foo</div>
<div class="line">cpu,cpuacct:/bar</div>
<div class="line">freezer:/</div>
<div class="line">freezer:/foo</div>
</div><!-- fragment --> I.e. there is <code>cpu</code> and <code>cpuacct</code> controller mounted together in one hierarchy, with <code>foo</code> and <code>bar</code> groups. In addition, <code>freezer</code> is mounted as separate hierarchy, with only one <code>foo</code> group.</dd></dl>
<dl class="section user"><dt></dt><dd>Following code creates <code>struct cgroup*</code> structure, which represents one group <code>cpu,cpuacct:/foo</code>: <div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structcgroup.html">cgroup</a> *foo = <a class="code hl_function" href="group__group__groups.html#gad34c82ead174988d418f3dcb003aaca7">cgroup_new_cgroup</a>(<span class="stringliteral">&quot;foo&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="group__group__groups.html#ga3929afd6ced9fe877613286b5f06cf8d">cgroup_add_controller</a>(foo, <span class="stringliteral">&quot;cpu&quot;</span>);</div>
<div class="ttc" id="agroup__group__groups_html_ga3929afd6ced9fe877613286b5f06cf8d"><div class="ttname"><a href="group__group__groups.html#ga3929afd6ced9fe877613286b5f06cf8d">cgroup_add_controller</a></div><div class="ttdeci">struct cgroup_controller * cgroup_add_controller(struct cgroup *cgroup, const char *name)</div><div class="ttdef"><b>Definition:</b> wrapper.c:61</div></div>
<div class="ttc" id="agroup__group__groups_html_gad34c82ead174988d418f3dcb003aaca7"><div class="ttname"><a href="group__group__groups.html#gad34c82ead174988d418f3dcb003aaca7">cgroup_new_cgroup</a></div><div class="ttdeci">struct cgroup * cgroup_new_cgroup(const char *name)</div><div class="ttdef"><b>Definition:</b> wrapper.c:43</div></div>
<div class="ttc" id="astructcgroup_html"><div class="ttname"><a href="structcgroup.html">cgroup</a></div><div class="ttdef"><b>Definition:</b> libcgroup-internal.h:117</div></div>
</div><!-- fragment --> Now, you can call e.g. <a class="el" href="group__group__groups.html#ga1dca18434e5d6be30c28c556da94f565">cgroup_delete_cgroup()</a> and the group is deleted from the hierarchy. You can note that it's enough to add only one controller to the group to fully identify a group in <code>cpu,cpuacct</code> hierarchy.</dd></dl>
<dl class="section user"><dt></dt><dd>Following code creates <code>struct cgroup*</code> structure, which represents <b>two</b> groups, <code>cpu,cpuacct:/foo</code> and <code>freezer:/foo</code>: <div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structcgroup.html">cgroup</a> *foo = <a class="code hl_function" href="group__group__groups.html#gad34c82ead174988d418f3dcb003aaca7">cgroup_new_cgroup</a>(<span class="stringliteral">&quot;foo&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="group__group__groups.html#ga3929afd6ced9fe877613286b5f06cf8d">cgroup_add_controller</a>(foo, <span class="stringliteral">&quot;cpu&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="group__group__groups.html#ga3929afd6ced9fe877613286b5f06cf8d">cgroup_add_controller</a>(foo, <span class="stringliteral">&quot;freezer&quot;</span>);</div>
</div><!-- fragment --> Now, if you call e.g. <a class="el" href="group__group__groups.html#ga1dca18434e5d6be30c28c556da94f565">cgroup_delete_cgroup()</a>, the group gets deleted from <b>both</b> hierarchies.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>add some propaganda what's so great on this approach... I personally think it is broken and confusing (see TODOs below).</dd></dl>
<p >Following functions are provided to create/destroy various libcgroup structures. Please note that none of these functions actually create or delete a cgroup in kernel! </p>
</td></tr>
<tr class="memitem:gad34c82ead174988d418f3dcb003aaca7"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcgroup.html">cgroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#gad34c82ead174988d418f3dcb003aaca7">cgroup_new_cgroup</a> (const char *name)</td></tr>
<tr class="separator:gad34c82ead174988d418f3dcb003aaca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3929afd6ced9fe877613286b5f06cf8d"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#ga3929afd6ced9fe877613286b5f06cf8d">cgroup_add_controller</a> (struct <a class="el" href="structcgroup.html">cgroup</a> *<a class="el" href="structcgroup.html">cgroup</a>, const char *name)</td></tr>
<tr class="separator:ga3929afd6ced9fe877613286b5f06cf8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae870d271b789b5c54c2e3d35de3cd6f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#gae870d271b789b5c54c2e3d35de3cd6f9">cgroup_add_all_controllers</a> (struct <a class="el" href="structcgroup.html">cgroup</a> *<a class="el" href="structcgroup.html">cgroup</a>)</td></tr>
<tr class="separator:gae870d271b789b5c54c2e3d35de3cd6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b60ab9187a883a2ae114f8d87191e27"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#ga6b60ab9187a883a2ae114f8d87191e27">cgroup_get_controller</a> (struct <a class="el" href="structcgroup.html">cgroup</a> *<a class="el" href="structcgroup.html">cgroup</a>, const char *name)</td></tr>
<tr class="separator:ga6b60ab9187a883a2ae114f8d87191e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab20fdb1ae479f8baac482336abf73900"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#gab20fdb1ae479f8baac482336abf73900">cgroup_free</a> (struct <a class="el" href="structcgroup.html">cgroup</a> **<a class="el" href="structcgroup.html">cgroup</a>)</td></tr>
<tr class="separator:gab20fdb1ae479f8baac482336abf73900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92d27c9ff0d655838642a7aa68497596"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#ga92d27c9ff0d655838642a7aa68497596">cgroup_free_controllers</a> (struct <a class="el" href="structcgroup.html">cgroup</a> *<a class="el" href="structcgroup.html">cgroup</a>)</td></tr>
<tr class="separator:ga92d27c9ff0d655838642a7aa68497596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4ffad2eccf9fcbfa8a551e269e0ad58"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#gad4ffad2eccf9fcbfa8a551e269e0ad58">NO_PERMS</a>&#160;&#160;&#160;(-1U)</td></tr>
<tr class="separator:gad4ffad2eccf9fcbfa8a551e269e0ad58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a7954a987e3fbf8eabcc94cf381353e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#ga2a7954a987e3fbf8eabcc94cf381353e">NO_UID_GID</a>&#160;&#160;&#160;(-1U)</td></tr>
<tr class="separator:ga2a7954a987e3fbf8eabcc94cf381353e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Group manipulation API</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >Using following functions you can create and remove control groups and change their parameters. </p><dl class="section note"><dt>Note</dt><dd>All access to kernel is through previously mounted cgroup filesystems. <code>libcgroup</code> does not mount/unmount anything for you. </dd></dl>
</td></tr>
<tr class="memitem:gadb8e13df6064841d3c9707960f782fa7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#gadb8e13df6064841d3c9707960f782fa7">cgroup_create_cgroup</a> (struct <a class="el" href="structcgroup.html">cgroup</a> *<a class="el" href="structcgroup.html">cgroup</a>, int ignore_ownership)</td></tr>
<tr class="separator:gadb8e13df6064841d3c9707960f782fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90e1ce96f3cb540f7e82d076dd938f62"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#ga90e1ce96f3cb540f7e82d076dd938f62">cgroup_create_cgroup_from_parent</a> (struct <a class="el" href="structcgroup.html">cgroup</a> *<a class="el" href="structcgroup.html">cgroup</a>, int ignore_ownership)</td></tr>
<tr class="separator:ga90e1ce96f3cb540f7e82d076dd938f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31ba5e865ae8d58b4453c0ef06d2c071"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#ga31ba5e865ae8d58b4453c0ef06d2c071">cgroup_modify_cgroup</a> (struct <a class="el" href="structcgroup.html">cgroup</a> *<a class="el" href="structcgroup.html">cgroup</a>)</td></tr>
<tr class="separator:ga31ba5e865ae8d58b4453c0ef06d2c071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dca18434e5d6be30c28c556da94f565"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#ga1dca18434e5d6be30c28c556da94f565">cgroup_delete_cgroup</a> (struct <a class="el" href="structcgroup.html">cgroup</a> *<a class="el" href="structcgroup.html">cgroup</a>, int ignore_migration)</td></tr>
<tr class="separator:ga1dca18434e5d6be30c28c556da94f565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga860c1ec70189c969b2c8373fc1e96d36"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#ga860c1ec70189c969b2c8373fc1e96d36">cgroup_delete_cgroup_ext</a> (struct <a class="el" href="structcgroup.html">cgroup</a> *<a class="el" href="structcgroup.html">cgroup</a>, int flags)</td></tr>
<tr class="separator:ga860c1ec70189c969b2c8373fc1e96d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Other functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >Helper functions to manipulate with control groups. </p>
</td></tr>
<tr class="memitem:gad4ba31fe5a8bba63b33b1ea339b849e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#gad4ba31fe5a8bba63b33b1ea339b849e6">cgroup_get_cgroup</a> (struct <a class="el" href="structcgroup.html">cgroup</a> *<a class="el" href="structcgroup.html">cgroup</a>)</td></tr>
<tr class="separator:gad4ba31fe5a8bba63b33b1ea339b849e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa981a95e0917d3167601a4c1b392336a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#gaa981a95e0917d3167601a4c1b392336a">cgroup_copy_cgroup</a> (struct <a class="el" href="structcgroup.html">cgroup</a> *dst, struct <a class="el" href="structcgroup.html">cgroup</a> *src)</td></tr>
<tr class="separator:gaa981a95e0917d3167601a4c1b392336a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86898b59e50335f99fe84a11fa38d3fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#ga86898b59e50335f99fe84a11fa38d3fc">cgroup_compare_cgroup</a> (struct <a class="el" href="structcgroup.html">cgroup</a> *cgroup_a, struct <a class="el" href="structcgroup.html">cgroup</a> *cgroup_b)</td></tr>
<tr class="separator:ga86898b59e50335f99fe84a11fa38d3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1725c50c49cec4b0bdad1f26b150ca7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#gab1725c50c49cec4b0bdad1f26b150ca7">cgroup_compare_controllers</a> (struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *cgca, struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *cgcb)</td></tr>
<tr class="separator:gab1725c50c49cec4b0bdad1f26b150ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53b9e13e30660c805ab5773d69397a43"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#ga53b9e13e30660c805ab5773d69397a43">cgroup_set_uid_gid</a> (struct <a class="el" href="structcgroup.html">cgroup</a> *<a class="el" href="structcgroup.html">cgroup</a>, uid_t tasks_uid, gid_t tasks_gid, uid_t control_uid, gid_t control_gid)</td></tr>
<tr class="separator:ga53b9e13e30660c805ab5773d69397a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga007d21c304d9cc6e948dc0ae51ecfa86"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#ga007d21c304d9cc6e948dc0ae51ecfa86">cgroup_get_uid_gid</a> (struct <a class="el" href="structcgroup.html">cgroup</a> *<a class="el" href="structcgroup.html">cgroup</a>, uid_t *tasks_uid, gid_t *tasks_gid, uid_t *control_uid, gid_t *control_gid)</td></tr>
<tr class="separator:ga007d21c304d9cc6e948dc0ae51ecfa86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0400f1ff2fba7fbb6db82d97039d92b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#gaa0400f1ff2fba7fbb6db82d97039d92b">cgroup_set_permissions</a> (struct <a class="el" href="structcgroup.html">cgroup</a> *<a class="el" href="structcgroup.html">cgroup</a>, mode_t control_dperm, mode_t control_fperm, mode_t task_fperm)</td></tr>
<tr class="separator:gaa0400f1ff2fba7fbb6db82d97039d92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Group parameters</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >These are functions can read or modify parameter of a group. </p><dl class="section note"><dt>Note</dt><dd>All these functions read/write parameters to <code>libcgorup</code> internal structures. Use <a class="el" href="group__group__groups.html#gad4ba31fe5a8bba63b33b1ea339b849e6">cgroup_get_cgroup()</a> to load parameters from kernel to these internal structures and <a class="el" href="group__group__groups.html#ga31ba5e865ae8d58b4453c0ef06d2c071">cgroup_modify_cgroup()</a> or <a class="el" href="group__group__groups.html#gadb8e13df6064841d3c9707960f782fa7">cgroup_create_cgroup()</a> to write changes to kernel. </dd></dl>
</td></tr>
<tr class="memitem:ga4817c68ab791c09c07b663c29b3fb029"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#ga4817c68ab791c09c07b663c29b3fb029">cgroup_add_value_string</a> (struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *controller, const char *name, const char *value)</td></tr>
<tr class="separator:ga4817c68ab791c09c07b663c29b3fb029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c973bb5ce99e7a91def2032f23d7087"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#ga6c973bb5ce99e7a91def2032f23d7087">cgroup_add_value_int64</a> (struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *controller, const char *name, int64_t value)</td></tr>
<tr class="separator:ga6c973bb5ce99e7a91def2032f23d7087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9d2216205b96278c626122f8d5e63bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#gad9d2216205b96278c626122f8d5e63bb">cgroup_add_value_uint64</a> (struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *controller, const char *name, u_int64_t value)</td></tr>
<tr class="separator:gad9d2216205b96278c626122f8d5e63bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b191a600f84b00ea7afd12c01d918f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#ga4b191a600f84b00ea7afd12c01d918f3">cgroup_add_value_bool</a> (struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *controller, const char *name, bool value)</td></tr>
<tr class="separator:ga4b191a600f84b00ea7afd12c01d918f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaa51e5ffe09f8ad05585a1d3b6f7fa9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#gafaa51e5ffe09f8ad05585a1d3b6f7fa9">cgroup_get_value_string</a> (struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *controller, const char *name, char **value)</td></tr>
<tr class="separator:gafaa51e5ffe09f8ad05585a1d3b6f7fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fe9b05f26b3cab21fc446c9a2700526"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#ga0fe9b05f26b3cab21fc446c9a2700526">cgroup_get_value_int64</a> (struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *controller, const char *name, int64_t *value)</td></tr>
<tr class="separator:ga0fe9b05f26b3cab21fc446c9a2700526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga951861259c0373895bfb637fce337312"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#ga951861259c0373895bfb637fce337312">cgroup_get_value_uint64</a> (struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *controller, const char *name, u_int64_t *value)</td></tr>
<tr class="separator:ga951861259c0373895bfb637fce337312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab95007148eac89b7e935d93a4524787b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#gab95007148eac89b7e935d93a4524787b">cgroup_get_value_bool</a> (struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *controller, const char *name, bool *value)</td></tr>
<tr class="separator:gab95007148eac89b7e935d93a4524787b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga938febc02b59cbeb8e4ceb2dc7fdac82"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#ga938febc02b59cbeb8e4ceb2dc7fdac82">cgroup_set_value_string</a> (struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *controller, const char *name, const char *value)</td></tr>
<tr class="separator:ga938febc02b59cbeb8e4ceb2dc7fdac82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5c39e51035cc43dd26a3c620441a956"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#gaa5c39e51035cc43dd26a3c620441a956">cgroup_set_value_int64</a> (struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *controller, const char *name, int64_t value)</td></tr>
<tr class="separator:gaa5c39e51035cc43dd26a3c620441a956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade01aa1fe30ccc968af9fe8a3bc821e5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#gade01aa1fe30ccc968af9fe8a3bc821e5">cgroup_set_value_uint64</a> (struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *controller, const char *name, u_int64_t value)</td></tr>
<tr class="separator:gade01aa1fe30ccc968af9fe8a3bc821e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb24892bc221cffee0f5fe07f64d54d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#gafb24892bc221cffee0f5fe07f64d54d7">cgroup_set_value_bool</a> (struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *controller, const char *name, bool value)</td></tr>
<tr class="separator:gafb24892bc221cffee0f5fe07f64d54d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25115085978ce2a8d671e7876cc49c1d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#ga25115085978ce2a8d671e7876cc49c1d">cgroup_get_value_name_count</a> (struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *controller)</td></tr>
<tr class="separator:ga25115085978ce2a8d671e7876cc49c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d01743fd3f97014e08fc67149ec5f0b"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#ga9d01743fd3f97014e08fc67149ec5f0b">cgroup_get_value_name</a> (struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *controller, int index)</td></tr>
<tr class="separator:ga9d01743fd3f97014e08fc67149ec5f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08a4fe913d59f61a39e61b8b02537dc2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#ga08a4fe913d59f61a39e61b8b02537dc2">cgroup_get_procs</a> (char *name, char *controller, pid_t **pids, int *size)</td></tr>
<tr class="separator:ga08a4fe913d59f61a39e61b8b02537dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef0bf6cd480f2dcb5e964de151a27dd1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#gaef0bf6cd480f2dcb5e964de151a27dd1">cg_chmod_recursive</a> (struct <a class="el" href="structcgroup.html">cgroup</a> *<a class="el" href="structcgroup.html">cgroup</a>, mode_t dir_mode, int dirm_change, mode_t file_mode, int filem_change)</td></tr>
<tr class="separator:gaef0bf6cd480f2dcb5e964de151a27dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab60b1f528fbfb17d69a88f499c7071aa"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#gab60b1f528fbfb17d69a88f499c7071aa">cgroup_get_cgroup_name</a> (struct <a class="el" href="structcgroup.html">cgroup</a> *<a class="el" href="structcgroup.html">cgroup</a>)</td></tr>
<tr class="separator:gab60b1f528fbfb17d69a88f499c7071aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a54be8341476951bd5bce94f521db6e"><td class="memItemLeft" align="right" valign="top"><a id="ga1a54be8341476951bd5bce94f521db6e" name="ga1a54be8341476951bd5bce94f521db6e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>cgroup_convert_cgroup</b> (struct <a class="el" href="structcgroup.html">cgroup</a> *const out_cgroup, enum cg_version_t out_version, const struct <a class="el" href="structcgroup.html">cgroup</a> *const in_cgroup, enum cg_version_t in_version)</td></tr>
<tr class="separator:ga1a54be8341476951bd5bce94f521db6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fd537a3ba09c497378dc494fa405f82"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#ga0fd537a3ba09c497378dc494fa405f82">cgroup_list_mount_points</a> (const enum cg_version_t cgrp_version, char ***mount_paths)</td></tr>
<tr class="separator:ga0fd537a3ba09c497378dc494fa405f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga452d8c5e95c8d694e26e7efda045360f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#ga452d8c5e95c8d694e26e7efda045360f">cgroup_get_controller_version</a> (const char *const controller, enum cg_version_t *const version)</td></tr>
<tr class="separator:ga452d8c5e95c8d694e26e7efda045360f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebf0c15818fa8201b8a458f3e3e044da"><td class="memItemLeft" align="right" valign="top">enum cg_setup_mode_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#gaebf0c15818fa8201b8a458f3e3e044da">cgroup_setup_mode</a> (void)</td></tr>
<tr class="separator:gaebf0c15818fa8201b8a458f3e3e044da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc512c3f20d1f18a0f0f3ca9e2fb136f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#gabc512c3f20d1f18a0f0f3ca9e2fb136f">cgroup_get_controller_count</a> (struct <a class="el" href="structcgroup.html">cgroup</a> *<a class="el" href="structcgroup.html">cgroup</a>)</td></tr>
<tr class="separator:gabc512c3f20d1f18a0f0f3ca9e2fb136f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5439bb5f149655f682a6438b17877db"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#gaf5439bb5f149655f682a6438b17877db">cgroup_get_controller_by_index</a> (struct <a class="el" href="structcgroup.html">cgroup</a> *<a class="el" href="structcgroup.html">cgroup</a>, int index)</td></tr>
<tr class="separator:gaf5439bb5f149655f682a6438b17877db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac13c5570894e6581bd1ebbdcbb73c74e"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#gac13c5570894e6581bd1ebbdcbb73c74e">cgroup_get_controller_name</a> (struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *controller)</td></tr>
<tr class="separator:gac13c5570894e6581bd1ebbdcbb73c74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5103da236354f658697c730cc6834f07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#ga5103da236354f658697c730cc6834f07">is_cgroup_mode_legacy</a> (void)</td></tr>
<tr class="separator:ga5103da236354f658697c730cc6834f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11a48a466c0d4b03d3480cd4d8c830f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#ga11a48a466c0d4b03d3480cd4d8c830f8">is_cgroup_mode_hybrid</a> (void)</td></tr>
<tr class="separator:ga11a48a466c0d4b03d3480cd4d8c830f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d360d903d69dfffd6d7a2904882f707"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__groups.html#ga7d360d903d69dfffd6d7a2904882f707">is_cgroup_mode_unified</a> (void)</td></tr>
<tr class="separator:ga7d360d903d69dfffd6d7a2904882f707"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gad4ffad2eccf9fcbfa8a551e269e0ad58" name="gad4ffad2eccf9fcbfa8a551e269e0ad58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4ffad2eccf9fcbfa8a551e269e0ad58">&#9670;&#160;</a></span>NO_PERMS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NO_PERMS&#160;&#160;&#160;(-1U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Uninitialized file/directory permissions used for task/control files. </p>

</div>
</div>
<a id="ga2a7954a987e3fbf8eabcc94cf381353e" name="ga2a7954a987e3fbf8eabcc94cf381353e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a7954a987e3fbf8eabcc94cf381353e">&#9670;&#160;</a></span>NO_UID_GID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NO_UID_GID&#160;&#160;&#160;(-1U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Uninitialized UID/GID used for task/control files. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaef0bf6cd480f2dcb5e964de151a27dd1" name="gaef0bf6cd480f2dcb5e964de151a27dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef0bf6cd480f2dcb5e964de151a27dd1">&#9670;&#160;</a></span>cg_chmod_recursive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cg_chmod_recursive </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup.html">cgroup</a> *&#160;</td>
          <td class="paramname"><em>cgroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&#160;</td>
          <td class="paramname"><em>dir_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dirm_change</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&#160;</td>
          <td class="paramname"><em>file_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>filem_change</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Change permission of files and directories of given group </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cgroup</td><td>The cgroup which permissions should be changed </td></tr>
    <tr><td class="paramname">dir_mode</td><td>The permission mode of group directory </td></tr>
    <tr><td class="paramname">dirm_change</td><td>Denotes whether the directory change should be done </td></tr>
    <tr><td class="paramname">file_mode</td><td>The permission mode of group files </td></tr>
    <tr><td class="paramname">filem_change</td><td>Denotes whether the directory change should be done </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae870d271b789b5c54c2e3d35de3cd6f9" name="gae870d271b789b5c54c2e3d35de3cd6f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae870d271b789b5c54c2e3d35de3cd6f9">&#9670;&#160;</a></span>cgroup_add_all_controllers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_add_all_controllers </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup.html">cgroup</a> *&#160;</td>
          <td class="paramname"><em>cgroup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Attach all mounted controllers to given cgroup. This function just modifies internal libcgroup structure, not the kernel control group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cgroup</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero or error number </dd></dl>

</div>
</div>
<a id="ga3929afd6ced9fe877613286b5f06cf8d" name="ga3929afd6ced9fe877613286b5f06cf8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3929afd6ced9fe877613286b5f06cf8d">&#9670;&#160;</a></span>cgroup_add_controller()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> * cgroup_add_controller </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup.html">cgroup</a> *&#160;</td>
          <td class="paramname"><em>cgroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Attach new controller to cgroup. This function just modifies internal libcgroup structure, not the kernel control group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cgroup</td><td></td></tr>
    <tr><td class="paramname">name</td><td>The name of the controller, e.g. "freezer". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Created controller or NULL on error. </dd></dl>

</div>
</div>
<a id="ga4b191a600f84b00ea7afd12c01d918f3" name="ga4b191a600f84b00ea7afd12c01d918f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b191a600f84b00ea7afd12c01d918f3">&#9670;&#160;</a></span>cgroup_add_value_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_add_value_bool </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *&#160;</td>
          <td class="paramname"><em>controller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Add parameter and its value to internal <code>libcgroup</code> structures. Use <a class="el" href="group__group__groups.html#ga31ba5e865ae8d58b4453c0ef06d2c071">cgroup_modify_cgroup()</a> or <a class="el" href="group__group__groups.html#gadb8e13df6064841d3c9707960f782fa7">cgroup_create_cgroup()</a> to write it to kernel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">controller</td><td></td></tr>
    <tr><td class="paramname">name</td><td>The name of the parameter. </td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6c973bb5ce99e7a91def2032f23d7087" name="ga6c973bb5ce99e7a91def2032f23d7087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c973bb5ce99e7a91def2032f23d7087">&#9670;&#160;</a></span>cgroup_add_value_int64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_add_value_int64 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *&#160;</td>
          <td class="paramname"><em>controller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Add parameter and its value to internal <code>libcgroup</code> structures. Use <a class="el" href="group__group__groups.html#ga31ba5e865ae8d58b4453c0ef06d2c071">cgroup_modify_cgroup()</a> or <a class="el" href="group__group__groups.html#gadb8e13df6064841d3c9707960f782fa7">cgroup_create_cgroup()</a> to write it to kernel. Content of the value is copied to internal structures and is not needed after return from the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">controller</td><td></td></tr>
    <tr><td class="paramname">name</td><td>The name of the parameter. </td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4817c68ab791c09c07b663c29b3fb029" name="ga4817c68ab791c09c07b663c29b3fb029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4817c68ab791c09c07b663c29b3fb029">&#9670;&#160;</a></span>cgroup_add_value_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_add_value_string </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *&#160;</td>
          <td class="paramname"><em>controller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Add parameter and its value to internal <code>libcgroup</code> structures. Use <a class="el" href="group__group__groups.html#ga31ba5e865ae8d58b4453c0ef06d2c071">cgroup_modify_cgroup()</a> or <a class="el" href="group__group__groups.html#gadb8e13df6064841d3c9707960f782fa7">cgroup_create_cgroup()</a> to write it to kernel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">controller</td><td></td></tr>
    <tr><td class="paramname">name</td><td>The name of the parameter. </td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad9d2216205b96278c626122f8d5e63bb" name="gad9d2216205b96278c626122f8d5e63bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9d2216205b96278c626122f8d5e63bb">&#9670;&#160;</a></span>cgroup_add_value_uint64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_add_value_uint64 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *&#160;</td>
          <td class="paramname"><em>controller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Add parameter and its value to internal <code>libcgroup</code> structures. Use <a class="el" href="group__group__groups.html#ga31ba5e865ae8d58b4453c0ef06d2c071">cgroup_modify_cgroup()</a> or <a class="el" href="group__group__groups.html#gadb8e13df6064841d3c9707960f782fa7">cgroup_create_cgroup()</a> to write it to kernel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">controller</td><td></td></tr>
    <tr><td class="paramname">name</td><td>The name of the parameter. </td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga86898b59e50335f99fe84a11fa38d3fc" name="ga86898b59e50335f99fe84a11fa38d3fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86898b59e50335f99fe84a11fa38d3fc">&#9670;&#160;</a></span>cgroup_compare_cgroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_compare_cgroup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup.html">cgroup</a> *&#160;</td>
          <td class="paramname"><em>cgroup_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcgroup.html">cgroup</a> *&#160;</td>
          <td class="paramname"><em>cgroup_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Compare names, owners, controllers, parameters and values of two groups.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cgroup_a</td><td></td></tr>
    <tr><td class="paramname">cgroup_b</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if the groups are the same. </td></tr>
    <tr><td class="paramname">ECGROUPNOTEQUAL</td><td>if the groups are not the same. </td></tr>
    <tr><td class="paramname">ECGCONTROLLERNOTEQUAL</td><td>if the only difference are controllers, parameters or their values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab1725c50c49cec4b0bdad1f26b150ca7" name="gab1725c50c49cec4b0bdad1f26b150ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1725c50c49cec4b0bdad1f26b150ca7">&#9670;&#160;</a></span>cgroup_compare_controllers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_compare_controllers </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *&#160;</td>
          <td class="paramname"><em>cgca</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *&#160;</td>
          <td class="paramname"><em>cgcb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Compare names, parameters and values of two controllers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cgca</td><td></td></tr>
    <tr><td class="paramname">cgcb</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if the controllers are the same. </td></tr>
    <tr><td class="paramname">ECGCONTROLLERNOTEQUAL</td><td>if the controllers are not equal. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa981a95e0917d3167601a4c1b392336a" name="gaa981a95e0917d3167601a4c1b392336a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa981a95e0917d3167601a4c1b392336a">&#9670;&#160;</a></span>cgroup_copy_cgroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_copy_cgroup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup.html">cgroup</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcgroup.html">cgroup</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Copy all controllers, their parameters and values. Group name, permissions and ownerships are not coppied. All existing controllers in the source group are discarded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>Destination group. </td></tr>
    <tr><td class="paramname">src</td><td>Source group.</td></tr>
  </table>
  </dd>
</dl>
<p>@dst: Destination control group @src: Source from which values will be copied to dst</p>
<p >Create a duplicate copy of src in dst. This will be useful for those who that intend to create new instances based on an existing control group </p>

</div>
</div>
<a id="gadb8e13df6064841d3c9707960f782fa7" name="gadb8e13df6064841d3c9707960f782fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb8e13df6064841d3c9707960f782fa7">&#9670;&#160;</a></span>cgroup_create_cgroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_create_cgroup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup.html">cgroup</a> *&#160;</td>
          <td class="paramname"><em>cgroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ignore_ownership</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Physically create a control group in kernel. The group is created in all hierarchies, which cover controllers added by <a class="el" href="group__group__groups.html#ga3929afd6ced9fe877613286b5f06cf8d">cgroup_add_controller()</a>. All parameters set by cgroup_add_value_* functions are written. The created groups has owner which was set by <a class="el" href="group__group__groups.html#ga53b9e13e30660c805ab5773d69397a43">cgroup_set_uid_gid()</a> and permissions set by cgroup_set_permissions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cgroup</td><td></td></tr>
    <tr><td class="paramname">ignore_ownership</td><td>When nozero, all errors are ignored when setting owner of the group and/or its tasks file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>what is ignore_ownership good for? </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ECGROUPNOTEQUAL</td><td>if not all specified controller parameters were successfully set.</td></tr>
  </table>
  </dd>
</dl>
<p>cgroup_create_cgroup creates a new control group. struct cgroup *cgroup: The control group to be created</p>
<p >returns 0 on success. We recommend calling cg_delete_cgroup if this routine fails. That should do the cleanup operation. If ECGCANTSETVALUE is returned, the group was created successfully but not all controller parameters were successfully set. </p>

</div>
</div>
<a id="ga90e1ce96f3cb540f7e82d076dd938f62" name="ga90e1ce96f3cb540f7e82d076dd938f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90e1ce96f3cb540f7e82d076dd938f62">&#9670;&#160;</a></span>cgroup_create_cgroup_from_parent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_create_cgroup_from_parent </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup.html">cgroup</a> *&#160;</td>
          <td class="paramname"><em>cgroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ignore_ownership</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Physically create new control group in kernel, with all parameters and values copied from its parent group. The group is created in all hierarchies, where the parent group exists. I.e. following code creates subgroup in all hierarchies, because all of them have root (=parent) group. </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structcgroup.html">cgroup</a> *foo = <a class="code hl_function" href="group__group__groups.html#gad34c82ead174988d418f3dcb003aaca7">cgroup_new_cgroup</a>(<span class="stringliteral">&quot;foo&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="group__group__groups.html#ga90e1ce96f3cb540f7e82d076dd938f62">cgroup_create_cgroup_from_parent</a>(foo, 0);</div>
<div class="ttc" id="agroup__group__groups_html_ga90e1ce96f3cb540f7e82d076dd938f62"><div class="ttname"><a href="group__group__groups.html#ga90e1ce96f3cb540f7e82d076dd938f62">cgroup_create_cgroup_from_parent</a></div><div class="ttdeci">int cgroup_create_cgroup_from_parent(struct cgroup *cgroup, int ignore_ownership)</div><div class="ttdef"><b>Definition:</b> api.c:3102</div></div>
</div><!-- fragment --> <dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>what is this good for? Why the list of controllers added by <a class="el" href="group__group__groups.html#ga3929afd6ced9fe877613286b5f06cf8d">cgroup_add_controller()</a> is not used, like in <a class="el" href="group__group__groups.html#gadb8e13df6064841d3c9707960f782fa7">cgroup_create_cgroup()</a>? I can't crate subgroup of root group in just one hierarchy with this function!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cgroup</td><td>The cgroup to create. Only it's name is used, everything else is discarded. </td></tr>
    <tr><td class="paramname">ignore_ownership</td><td>When nozero, all errors are ignored when setting owner of the group and/or its tasks file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>what is ignore_ownership good for? </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ECGROUPNOTEQUAL</td><td>if not all inherited controller parameters were successfully set (this is expected).</td></tr>
  </table>
  </dd>
</dl>
<p>@cgroup: cgroup data structure to be filled with parent values and then passed down for creation @ignore_ownership: Ignore doing a chown on the newly created cgroup </p><dl class="section return"><dt>Returns</dt><dd>0 on success, &gt; 0 on failure. If ECGCANTSETVALUE is returned, the group was created successfully, but not all controller parameters were copied from the parent successfully; unfortunately, this is expected... </dd></dl>

</div>
</div>
<a id="ga1dca18434e5d6be30c28c556da94f565" name="ga1dca18434e5d6be30c28c556da94f565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1dca18434e5d6be30c28c556da94f565">&#9670;&#160;</a></span>cgroup_delete_cgroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_delete_cgroup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup.html">cgroup</a> *&#160;</td>
          <td class="paramname"><em>cgroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ignore_migration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Physically remove a control group from kernel. The group is removed from all hierarchies, which cover controllers added by <a class="el" href="group__group__groups.html#ga3929afd6ced9fe877613286b5f06cf8d">cgroup_add_controller()</a> or <a class="el" href="group__group__groups.html#gad4ba31fe5a8bba63b33b1ea339b849e6">cgroup_get_cgroup()</a>. All tasks inside the group are automatically moved to parent group.</p>
<p >The group being removed must be empty, i.e. without subgroups. Use <a class="el" href="group__group__groups.html#ga860c1ec70189c969b2c8373fc1e96d36">cgroup_delete_cgroup_ext()</a> for recursive delete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cgroup</td><td></td></tr>
    <tr><td class="paramname">ignore_migration</td><td>When nozero, all errors are ignored when migrating tasks from the group to the parent group. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>what is ignore_migration good for? rmdir() will fail if tasks were not moved. </dd></dl>
<p >cgroup_delete cgroup deletes a control group. struct cgroup *cgroup takes the group which is to be deleted.</p>
<p >returns 0 on success. </p>

</div>
</div>
<a id="ga860c1ec70189c969b2c8373fc1e96d36" name="ga860c1ec70189c969b2c8373fc1e96d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga860c1ec70189c969b2c8373fc1e96d36">&#9670;&#160;</a></span>cgroup_delete_cgroup_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_delete_cgroup_ext </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup.html">cgroup</a> *&#160;</td>
          <td class="paramname"><em>cgroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Physically remove a control group from kernel. All tasks are automatically moved to parent group. If CGFLAG_DELETE_IGNORE_MIGRATION flag is used, the errors that occurred during the task movement are ignored. CGFLAG_DELETE_RECURSIVE flag specifies that all subgroups should be removed too. If root group is being removed with this flag specified, all subgroups are removed but the root group itself is left undeleted. </p><dl class="section see"><dt>See also</dt><dd>cgroup_delete_flag.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cgroup</td><td></td></tr>
    <tr><td class="paramname">flags</td><td>Combination of CGFLAG_DELETE_* flags, which indicate what and how to delete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab20fdb1ae479f8baac482336abf73900" name="gab20fdb1ae479f8baac482336abf73900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab20fdb1ae479f8baac482336abf73900">&#9670;&#160;</a></span>cgroup_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgroup_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup.html">cgroup</a> **&#160;</td>
          <td class="paramname"><em>cgroup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Free internal <code>cgroup</code> structure. This function frees also all controllers attached to the <code>cgroup</code>, including all parameters and their values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cgroup</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga92d27c9ff0d655838642a7aa68497596" name="ga92d27c9ff0d655838642a7aa68497596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92d27c9ff0d655838642a7aa68497596">&#9670;&#160;</a></span>cgroup_free_controllers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgroup_free_controllers </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup.html">cgroup</a> *&#160;</td>
          <td class="paramname"><em>cgroup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Free internal list of controllers from the group. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>should this function be public??? </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cgroup</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad4ba31fe5a8bba63b33b1ea339b849e6" name="gad4ba31fe5a8bba63b33b1ea339b849e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4ba31fe5a8bba63b33b1ea339b849e6">&#9670;&#160;</a></span>cgroup_get_cgroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_get_cgroup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup.html">cgroup</a> *&#160;</td>
          <td class="paramname"><em>cgroup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Read all information regarding the group from kernel. Based on name of the group, list of controllers and all parameters and their values are read from all hierarchies, where a group with given name exists. All existing controllers are replaced. I.e. following code will fill <code>root</code> with controllers from all hierarchies, because the root group is available in all of them. </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structcgroup.html">cgroup</a> *root = <a class="code hl_function" href="group__group__groups.html#gad34c82ead174988d418f3dcb003aaca7">cgroup_new_cgroup</a>(<span class="stringliteral">&quot;/&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="group__group__groups.html#gad4ba31fe5a8bba63b33b1ea339b849e6">cgroup_get_cgroup</a>(root);</div>
<div class="ttc" id="agroup__group__groups_html_gad4ba31fe5a8bba63b33b1ea339b849e6"><div class="ttname"><a href="group__group__groups.html#gad4ba31fe5a8bba63b33b1ea339b849e6">cgroup_get_cgroup</a></div><div class="ttdeci">int cgroup_get_cgroup(struct cgroup *cgroup)</div><div class="ttdef"><b>Definition:</b> api.c:3642</div></div>
</div><!-- fragment --><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>what is this function good for? Why is not considered only the list of controllers attached by <a class="el" href="group__group__groups.html#ga3929afd6ced9fe877613286b5f06cf8d">cgroup_add_controller()</a>? What owners will return <a class="el" href="group__group__groups.html#ga007d21c304d9cc6e948dc0ae51ecfa86">cgroup_get_uid_gid()</a> if the group is in multiple hierarchies, each with different owner of tasks file?</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cgroup</td><td>The cgroup to load. Only it's name is used, everything else is replaced. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab60b1f528fbfb17d69a88f499c7071aa" name="gab60b1f528fbfb17d69a88f499c7071aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab60b1f528fbfb17d69a88f499c7071aa">&#9670;&#160;</a></span>cgroup_get_cgroup_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * cgroup_get_cgroup_name </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup.html">cgroup</a> *&#160;</td>
          <td class="paramname"><em>cgroup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the name of the cgroup from a given cgroup </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cgroup</td><td>The cgroup whose name is needed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6b60ab9187a883a2ae114f8d87191e27" name="ga6b60ab9187a883a2ae114f8d87191e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b60ab9187a883a2ae114f8d87191e27">&#9670;&#160;</a></span>cgroup_get_controller()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> * cgroup_get_controller </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup.html">cgroup</a> *&#160;</td>
          <td class="paramname"><em>cgroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return appropriate controller from given group. The controller must be added before using <a class="el" href="group__group__groups.html#ga3929afd6ced9fe877613286b5f06cf8d">cgroup_add_controller()</a> or loaded from kernel using <a class="el" href="group__group__groups.html#gad4ba31fe5a8bba63b33b1ea339b849e6">cgroup_get_cgroup()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cgroup</td><td></td></tr>
    <tr><td class="paramname">name</td><td>The name of the controller, e.g. "freezer". </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf5439bb5f149655f682a6438b17877db" name="gaf5439bb5f149655f682a6438b17877db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5439bb5f149655f682a6438b17877db">&#9670;&#160;</a></span>cgroup_get_controller_by_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> * cgroup_get_controller_by_index </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup.html">cgroup</a> *&#160;</td>
          <td class="paramname"><em>cgroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return requested controller from given group</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cgroup</td><td></td></tr>
    <tr><td class="paramname">index</td><td>The index into the cgroup controller list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabc512c3f20d1f18a0f0f3ca9e2fb136f" name="gabc512c3f20d1f18a0f0f3ca9e2fb136f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc512c3f20d1f18a0f0f3ca9e2fb136f">&#9670;&#160;</a></span>cgroup_get_controller_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_get_controller_count </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup.html">cgroup</a> *&#160;</td>
          <td class="paramname"><em>cgroup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return the number of controllers for the specified cgroup in libcgroup internal structures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cgroup</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Count of the controllers or -1 on error. </dd></dl>

</div>
</div>
<a id="gac13c5570894e6581bd1ebbdcbb73c74e" name="gac13c5570894e6581bd1ebbdcbb73c74e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac13c5570894e6581bd1ebbdcbb73c74e">&#9670;&#160;</a></span>cgroup_get_controller_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * cgroup_get_controller_name </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *&#160;</td>
          <td class="paramname"><em>controller</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Given a controller pointer, get the name of the controller</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">controller</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>controller name string, NULL if there's an error </dd></dl>

</div>
</div>
<a id="ga452d8c5e95c8d694e26e7efda045360f" name="ga452d8c5e95c8d694e26e7efda045360f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga452d8c5e95c8d694e26e7efda045360f">&#9670;&#160;</a></span>cgroup_get_controller_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_get_controller_version </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>controller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum cg_version_t *const&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the cgroup version of a controller. Version is set to CGROUP_UNK if the version cannot be determined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">controller</td><td>The controller of interest </td></tr>
    <tr><td class="paramname">version</td><td>The version of the controller </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga08a4fe913d59f61a39e61b8b02537dc2" name="ga08a4fe913d59f61a39e61b8b02537dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08a4fe913d59f61a39e61b8b02537dc2">&#9670;&#160;</a></span>cgroup_get_procs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_get_procs </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>controller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pid_t **&#160;</td>
          <td class="paramname"><em>pids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the list of process in a cgroup. This list is guaranteed to be sorted. It is not necessary that it is unique. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the cgroup </td></tr>
    <tr><td class="paramname">controller</td><td>The name of the controller </td></tr>
    <tr><td class="paramname">pids</td><td>The list of pids. Should be uninitialized when passed to the API. Should be freed by the caller using free. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the pids array returned by the API. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga007d21c304d9cc6e948dc0ae51ecfa86" name="ga007d21c304d9cc6e948dc0ae51ecfa86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga007d21c304d9cc6e948dc0ae51ecfa86">&#9670;&#160;</a></span>cgroup_get_uid_gid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_get_uid_gid </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup.html">cgroup</a> *&#160;</td>
          <td class="paramname"><em>cgroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uid_t *&#160;</td>
          <td class="paramname"><em>tasks_uid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gid_t *&#160;</td>
          <td class="paramname"><em>tasks_gid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uid_t *&#160;</td>
          <td class="paramname"><em>control_uid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gid_t *&#160;</td>
          <td class="paramname"><em>control_gid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return owners of the group's <code>tasks</code> file and control files. The data is read from <code>libcgroup</code> internal <code>cgroup</code> structure, use <a class="el" href="group__group__groups.html#ga53b9e13e30660c805ab5773d69397a43">cgroup_set_uid_gid()</a> or <a class="el" href="group__group__groups.html#gad4ba31fe5a8bba63b33b1ea339b849e6">cgroup_get_cgroup()</a> to fill it. </p>

</div>
</div>
<a id="gab95007148eac89b7e935d93a4524787b" name="gab95007148eac89b7e935d93a4524787b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab95007148eac89b7e935d93a4524787b">&#9670;&#160;</a></span>cgroup_get_value_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_get_value_bool </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *&#160;</td>
          <td class="paramname"><em>controller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Read a parameter value from <code>libcgroup</code> internal structures. Use <code><a class="el" href="group__group__groups.html#gad4ba31fe5a8bba63b33b1ea339b849e6">cgroup_get_cgroup()</a></code> to fill these structures with data from kernel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">controller</td><td></td></tr>
    <tr><td class="paramname">name</td><td>The name of the parameter. </td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0fe9b05f26b3cab21fc446c9a2700526" name="ga0fe9b05f26b3cab21fc446c9a2700526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fe9b05f26b3cab21fc446c9a2700526">&#9670;&#160;</a></span>cgroup_get_value_int64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_get_value_int64 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *&#160;</td>
          <td class="paramname"><em>controller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Read a parameter value from <code>libcgroup</code> internal structures. Use <code><a class="el" href="group__group__groups.html#gad4ba31fe5a8bba63b33b1ea339b849e6">cgroup_get_cgroup()</a></code> to fill these structures with data from kernel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">controller</td><td></td></tr>
    <tr><td class="paramname">name</td><td>The name of the parameter. </td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9d01743fd3f97014e08fc67149ec5f0b" name="ga9d01743fd3f97014e08fc67149ec5f0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d01743fd3f97014e08fc67149ec5f0b">&#9670;&#160;</a></span>cgroup_get_value_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * cgroup_get_value_name </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *&#160;</td>
          <td class="paramname"><em>controller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return the name of parameter of controller at given index. The index goes from 0 to <a class="el" href="group__group__groups.html#ga25115085978ce2a8d671e7876cc49c1d">cgroup_get_value_name_count()</a>-1. Use this function to list all parameter of the controller.</p>
<dl class="section note"><dt>Note</dt><dd>The returned value is pointer to internal <code>libcgroup</code> structure, do not free it.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">controller</td><td></td></tr>
    <tr><td class="paramname">index</td><td>The index of the parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Name of the parameter. </dd></dl>

</div>
</div>
<a id="ga25115085978ce2a8d671e7876cc49c1d" name="ga25115085978ce2a8d671e7876cc49c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25115085978ce2a8d671e7876cc49c1d">&#9670;&#160;</a></span>cgroup_get_value_name_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_get_value_name_count </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *&#160;</td>
          <td class="paramname"><em>controller</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return the number of variables for the specified controller in <code>libcgroup</code> internal structures. Use <a class="el" href="group__group__groups.html#gad4ba31fe5a8bba63b33b1ea339b849e6">cgroup_get_cgroup()</a> to fill these structures with data from kernel. Use this function together with <a class="el" href="group__group__groups.html#ga9d01743fd3f97014e08fc67149ec5f0b">cgroup_get_value_name()</a> to list all parameters of a group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">controller</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Count of the parameters or -1 on error. </dd></dl>

</div>
</div>
<a id="gafaa51e5ffe09f8ad05585a1d3b6f7fa9" name="gafaa51e5ffe09f8ad05585a1d3b6f7fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafaa51e5ffe09f8ad05585a1d3b6f7fa9">&#9670;&#160;</a></span>cgroup_get_value_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_get_value_string </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *&#160;</td>
          <td class="paramname"><em>controller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Read a parameter value from <code>libcgroup</code> internal structures. Use <code><a class="el" href="group__group__groups.html#gad4ba31fe5a8bba63b33b1ea339b849e6">cgroup_get_cgroup()</a></code> to fill these structures with data from kernel. It's up to the caller to free returned value.</p>
<p >This function works only for 'short' parameters. Use <a class="el" href="group__group__iterators.html#ga1138e47f124f0f634586db5e0c4ae5de">cgroup_read_stats_begin()</a>, <a class="el" href="group__group__iterators.html#gaf95587508fc15d74fd5ed0df58024be7">cgroup_read_stats_next()</a> and <a class="el" href="group__group__iterators.html#gaba386d9db6cadc6ad85c2552f63447bb">cgroup_read_stats_end()</a> to read <code>stats</code> parameter, which can be longer than libcgroup's internal buffers. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>rephrase, it's too vague... How big is the buffer actually?</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">controller</td><td></td></tr>
    <tr><td class="paramname">name</td><td>The name of the parameter. </td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga951861259c0373895bfb637fce337312" name="ga951861259c0373895bfb637fce337312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga951861259c0373895bfb637fce337312">&#9670;&#160;</a></span>cgroup_get_value_uint64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_get_value_uint64 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *&#160;</td>
          <td class="paramname"><em>controller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int64_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Read a parameter value from <code>libcgroup</code> internal structures. Use <code><a class="el" href="group__group__groups.html#gad4ba31fe5a8bba63b33b1ea339b849e6">cgroup_get_cgroup()</a></code> to fill these structures with data from kernel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">controller</td><td></td></tr>
    <tr><td class="paramname">name</td><td>The name of the parameter. </td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0fd537a3ba09c497378dc494fa405f82" name="ga0fd537a3ba09c497378dc494fa405f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fd537a3ba09c497378dc494fa405f82">&#9670;&#160;</a></span>cgroup_list_mount_points()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_list_mount_points </td>
          <td>(</td>
          <td class="paramtype">const enum cg_version_t&#160;</td>
          <td class="paramname"><em>cgrp_version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char ***&#160;</td>
          <td class="paramname"><em>mount_paths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >List the mount paths, that matches the specified version</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cgrp_version</td><td>The cgroup type/version </td></tr>
    <tr><td class="paramname">mount_paths</td><td>Holds the list of mount paths </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 success and list of mounts paths in mount_paths ECGOTHER on failure and mount_paths is NULL. </dd></dl>

</div>
</div>
<a id="ga31ba5e865ae8d58b4453c0ef06d2c071" name="ga31ba5e865ae8d58b4453c0ef06d2c071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31ba5e865ae8d58b4453c0ef06d2c071">&#9670;&#160;</a></span>cgroup_modify_cgroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_modify_cgroup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup.html">cgroup</a> *&#160;</td>
          <td class="paramname"><em>cgroup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Physically modify a control group in kernel. All parameters added by cgroup_add_value_ or cgroup_set_value_ are written. Currently it's not possible to change and owner of a group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cgroup</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>cgroup_modify_cgroup modifies the cgroup control files. struct cgroup *cgroup: The name will be the cgroup to be modified. The values will be the values to be modified, those not mentioned in the structure will not be modified.</p>
<p >The uids cannot be modified yet.</p>
<p >returns 0 on success. </p>

</div>
</div>
<a id="gad34c82ead174988d418f3dcb003aaca7" name="gad34c82ead174988d418f3dcb003aaca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad34c82ead174988d418f3dcb003aaca7">&#9670;&#160;</a></span>cgroup_new_cgroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcgroup.html">cgroup</a> * cgroup_new_cgroup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Allocate new cgroup structure. This function itself does not create new control group in kernel, only new <code>struct cgroup</code> inside libcgroup!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Path to the group, relative from root group. Use <code>"/"</code> or <code>"."</code> for the root group itself and <code>"/foo/bar/baz"</code> or <code>"foo/bar/baz"</code> for subgroups. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>suggest one preferred way, either "/foo" or "foo". </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Created group or NULL on error. </dd></dl>

</div>
</div>
<a id="gaa0400f1ff2fba7fbb6db82d97039d92b" name="gaa0400f1ff2fba7fbb6db82d97039d92b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0400f1ff2fba7fbb6db82d97039d92b">&#9670;&#160;</a></span>cgroup_set_permissions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgroup_set_permissions </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup.html">cgroup</a> *&#160;</td>
          <td class="paramname"><em>cgroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&#160;</td>
          <td class="paramname"><em>control_dperm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&#160;</td>
          <td class="paramname"><em>control_fperm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&#160;</td>
          <td class="paramname"><em>task_fperm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Stores given file permissions of the group's control and tasks files into the <code>cgroup</code> data structure. Use NO_PERMS if permissions shouldn't be changed or a value which applicable to chmod(2). Please note that the given permissions are masked with the file owner's permissions. For example if a control file has permissions 640 and control_fperm is 471 the result will be 460. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cgroup</td><td></td></tr>
    <tr><td class="paramname">control_dperm</td><td>Directory permission for the group. </td></tr>
    <tr><td class="paramname">control_fperm</td><td>File permission for the control files. </td></tr>
    <tr><td class="paramname">task_fperm</td><td>File permissions for task file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga53b9e13e30660c805ab5773d69397a43" name="ga53b9e13e30660c805ab5773d69397a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53b9e13e30660c805ab5773d69397a43">&#9670;&#160;</a></span>cgroup_set_uid_gid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_set_uid_gid </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup.html">cgroup</a> *&#160;</td>
          <td class="paramname"><em>cgroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uid_t&#160;</td>
          <td class="paramname"><em>tasks_uid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gid_t&#160;</td>
          <td class="paramname"><em>tasks_gid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uid_t&#160;</td>
          <td class="paramname"><em>control_uid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gid_t&#160;</td>
          <td class="paramname"><em>control_gid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set owner of the group control files and the <code>tasks</code> file. This function modifies only <code>libcgroup</code> internal <code>cgroup</code> structure, use <a class="el" href="group__group__groups.html#gadb8e13df6064841d3c9707960f782fa7">cgroup_create_cgroup()</a> afterwards to create the group with given owners.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cgroup</td><td></td></tr>
    <tr><td class="paramname">tasks_uid</td><td>UID of the owner of group's <code>tasks</code> file. </td></tr>
    <tr><td class="paramname">tasks_gid</td><td>GID of the owner of group's <code>tasks</code> file. </td></tr>
    <tr><td class="paramname">control_uid</td><td>UID of the owner of group's control files (i.e. parameters). </td></tr>
    <tr><td class="paramname">control_gid</td><td>GID of the owner of group's control files (i.e. parameters). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafb24892bc221cffee0f5fe07f64d54d7" name="gafb24892bc221cffee0f5fe07f64d54d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb24892bc221cffee0f5fe07f64d54d7">&#9670;&#160;</a></span>cgroup_set_value_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_set_value_bool </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *&#160;</td>
          <td class="paramname"><em>controller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set a parameter value in <code>libcgroup</code> internal structures. Use <a class="el" href="group__group__groups.html#ga31ba5e865ae8d58b4453c0ef06d2c071">cgroup_modify_cgroup()</a> or <a class="el" href="group__group__groups.html#gadb8e13df6064841d3c9707960f782fa7">cgroup_create_cgroup()</a> to write it to kernel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">controller</td><td></td></tr>
    <tr><td class="paramname">name</td><td>The name of the parameter. </td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa5c39e51035cc43dd26a3c620441a956" name="gaa5c39e51035cc43dd26a3c620441a956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5c39e51035cc43dd26a3c620441a956">&#9670;&#160;</a></span>cgroup_set_value_int64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_set_value_int64 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *&#160;</td>
          <td class="paramname"><em>controller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set a parameter value in <code>libcgroup</code> internal structures. Use <a class="el" href="group__group__groups.html#ga31ba5e865ae8d58b4453c0ef06d2c071">cgroup_modify_cgroup()</a> or <a class="el" href="group__group__groups.html#gadb8e13df6064841d3c9707960f782fa7">cgroup_create_cgroup()</a> to write it to kernel. Content of the value is copied to internal structures and is not needed after return from the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">controller</td><td></td></tr>
    <tr><td class="paramname">name</td><td>The name of the parameter. </td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga938febc02b59cbeb8e4ceb2dc7fdac82" name="ga938febc02b59cbeb8e4ceb2dc7fdac82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga938febc02b59cbeb8e4ceb2dc7fdac82">&#9670;&#160;</a></span>cgroup_set_value_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_set_value_string </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *&#160;</td>
          <td class="paramname"><em>controller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set a parameter value in <code>libcgroup</code> internal structures. Use <a class="el" href="group__group__groups.html#ga31ba5e865ae8d58b4453c0ef06d2c071">cgroup_modify_cgroup()</a> or <a class="el" href="group__group__groups.html#gadb8e13df6064841d3c9707960f782fa7">cgroup_create_cgroup()</a> to write it to kernel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">controller</td><td></td></tr>
    <tr><td class="paramname">name</td><td>The name of the parameter. </td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gade01aa1fe30ccc968af9fe8a3bc821e5" name="gade01aa1fe30ccc968af9fe8a3bc821e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade01aa1fe30ccc968af9fe8a3bc821e5">&#9670;&#160;</a></span>cgroup_set_value_uint64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_set_value_uint64 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcgroup__controller.html">cgroup_controller</a> *&#160;</td>
          <td class="paramname"><em>controller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set a parameter value in <code>libcgroup</code> internal structures. Use <a class="el" href="group__group__groups.html#ga31ba5e865ae8d58b4453c0ef06d2c071">cgroup_modify_cgroup()</a> or <a class="el" href="group__group__groups.html#gadb8e13df6064841d3c9707960f782fa7">cgroup_create_cgroup()</a> to write it to kernel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">controller</td><td></td></tr>
    <tr><td class="paramname">name</td><td>The name of the parameter. </td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaebf0c15818fa8201b8a458f3e3e044da" name="gaebf0c15818fa8201b8a458f3e3e044da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebf0c15818fa8201b8a458f3e3e044da">&#9670;&#160;</a></span>cgroup_setup_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum cg_setup_mode_t cgroup_setup_mode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the current group setup mode (legacy/unified/hybrid)</p>
<dl class="section return"><dt>Returns</dt><dd>CGROUP_MODE_UNK on failure and setup mode on success</dd></dl>
<p>Finds the current cgroup setup mode (legacy/unified/hybrid). Returns unknown of failure and setup mode on success. </p>

</div>
</div>
<a id="ga11a48a466c0d4b03d3480cd4d8c830f8" name="ga11a48a466c0d4b03d3480cd4d8c830f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11a48a466c0d4b03d3480cd4d8c830f8">&#9670;&#160;</a></span>is_cgroup_mode_hybrid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_cgroup_mode_hybrid </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return true if cgroup setup mode is cgroup v1/v2 (hybrid), else returns false. </p>

</div>
</div>
<a id="ga5103da236354f658697c730cc6834f07" name="ga5103da236354f658697c730cc6834f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5103da236354f658697c730cc6834f07">&#9670;&#160;</a></span>is_cgroup_mode_legacy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_cgroup_mode_legacy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return true if cgroup setup mode is cgroup v1 (legacy), else returns false. </p>

</div>
</div>
<a id="ga7d360d903d69dfffd6d7a2904882f707" name="ga7d360d903d69dfffd6d7a2904882f707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d360d903d69dfffd6d7a2904882f707">&#9670;&#160;</a></span>is_cgroup_mode_unified()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_cgroup_mode_unified </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return true if cgroup setup mode is cgroup v2 (unified), else returns false. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
