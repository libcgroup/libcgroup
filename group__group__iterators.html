<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libcgroup: 3. Iterators</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libcgroup
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle"><div class="title">3. Iterators</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgroup__file__info.html">cgroup_file_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgroup__stat.html">cgroup_stat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgroup__mount__point.html">cgroup_mount_point</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcontroller__data.html">controller_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Walk through control group filesystem</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>This iterator returns all subgroups of given control group. It can be used to return all groups in given hierarchy, when root control group is provided. </p>
</td></tr>
<tr class="memitem:ga29a572cbc0c07e2b02dfa0f1ac0067d3" id="r_ga29a572cbc0c07e2b02dfa0f1ac0067d3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iterators.html#ga29a572cbc0c07e2b02dfa0f1ac0067d3">cgroup_walk_type</a> { <a class="el" href="group__group__iterators.html#gga29a572cbc0c07e2b02dfa0f1ac0067d3af865296e6a0e55cff574fbb132b9f913">CGROUP_WALK_TYPE_PRE_DIR</a> = 0x1
, <a class="el" href="group__group__iterators.html#gga29a572cbc0c07e2b02dfa0f1ac0067d3abf3c31227768960bd6622d2562aae3e1">CGROUP_WALK_TYPE_POST_DIR</a> = 0x2
 }</td></tr>
<tr class="separator:ga29a572cbc0c07e2b02dfa0f1ac0067d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga608b4aa32e2db58fed34771a6a272444" id="r_ga608b4aa32e2db58fed34771a6a272444"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iterators.html#ga608b4aa32e2db58fed34771a6a272444">cgroup_file_type</a> { <a class="el" href="group__group__iterators.html#gga608b4aa32e2db58fed34771a6a272444ad925cc45f1b34fe80e14fc6b05269740">CGROUP_FILE_TYPE_FILE</a>
, <a class="el" href="group__group__iterators.html#gga608b4aa32e2db58fed34771a6a272444a5418798fc4bf9634429c6af167a0e7c3">CGROUP_FILE_TYPE_DIR</a>
, <a class="el" href="group__group__iterators.html#gga608b4aa32e2db58fed34771a6a272444a24e202c59f318e63ad8cafcc1b4b102b">CGROUP_FILE_TYPE_OTHER</a>
 }</td></tr>
<tr class="separator:ga608b4aa32e2db58fed34771a6a272444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b19f10c06abb96d8c8ae88a04888a68" id="r_ga7b19f10c06abb96d8c8ae88a04888a68"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iterators.html#ga7b19f10c06abb96d8c8ae88a04888a68">cgroup_walk_tree_begin</a> (const char *controller, const char *base_path, int depth, void **handle, struct <a class="el" href="structcgroup__file__info.html">cgroup_file_info</a> *info, int *base_level)</td></tr>
<tr class="separator:ga7b19f10c06abb96d8c8ae88a04888a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga527f5499b0aa04d325074435baebdff1" id="r_ga527f5499b0aa04d325074435baebdff1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iterators.html#ga527f5499b0aa04d325074435baebdff1">cgroup_walk_tree_next</a> (int depth, void **handle, struct <a class="el" href="structcgroup__file__info.html">cgroup_file_info</a> *info, int base_level)</td></tr>
<tr class="separator:ga527f5499b0aa04d325074435baebdff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09a70990837a58e506a264f8c50d4cde" id="r_ga09a70990837a58e506a264f8c50d4cde"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iterators.html#ga09a70990837a58e506a264f8c50d4cde">cgroup_walk_tree_end</a> (void **handle)</td></tr>
<tr class="separator:ga09a70990837a58e506a264f8c50d4cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga645ec7a6206dffb32667e7a0e148edc8" id="r_ga645ec7a6206dffb32667e7a0e148edc8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iterators.html#ga645ec7a6206dffb32667e7a0e148edc8">cgroup_walk_tree_set_flags</a> (void **handle, int flags)</td></tr>
<tr class="separator:ga645ec7a6206dffb32667e7a0e148edc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9378ee0f1f6e65900df8e25b3d7ce236" id="r_ga9378ee0f1f6e65900df8e25b3d7ce236"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iterators.html#ga9378ee0f1f6e65900df8e25b3d7ce236">cgroup_read_value_begin</a> (const char *const controller, const char *path, const char *const name, void **handle, char *buffer, int max)</td></tr>
<tr class="separator:ga9378ee0f1f6e65900df8e25b3d7ce236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaced2fe331f19d599a3270db2440847cc" id="r_gaced2fe331f19d599a3270db2440847cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iterators.html#gaced2fe331f19d599a3270db2440847cc">cgroup_read_value_next</a> (void **handle, char *buffer, int max)</td></tr>
<tr class="separator:gaced2fe331f19d599a3270db2440847cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad348f041e283860cbf6bcea567e23a21" id="r_gad348f041e283860cbf6bcea567e23a21"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iterators.html#gad348f041e283860cbf6bcea567e23a21">cgroup_read_value_end</a> (void **handle)</td></tr>
<tr class="separator:gad348f041e283860cbf6bcea567e23a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Read group stats</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>libcgroup's <a class="el" href="group__group__groups.html#gafaa51e5ffe09f8ad05585a1d3b6f7fa9">cgroup_get_value_string()</a> reads only relatively short parameters of a group. Use following functions to read <code>stats</code> parameter, which can be quite long. </p>
</td></tr>
<tr class="memitem:ga1138e47f124f0f634586db5e0c4ae5de" id="r_ga1138e47f124f0f634586db5e0c4ae5de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iterators.html#ga1138e47f124f0f634586db5e0c4ae5de">cgroup_read_stats_begin</a> (const char *controller, const char *path, void **handle, struct <a class="el" href="structcgroup__stat.html">cgroup_stat</a> *stat)</td></tr>
<tr class="separator:ga1138e47f124f0f634586db5e0c4ae5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf95587508fc15d74fd5ed0df58024be7" id="r_gaf95587508fc15d74fd5ed0df58024be7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iterators.html#gaf95587508fc15d74fd5ed0df58024be7">cgroup_read_stats_next</a> (void **handle, struct <a class="el" href="structcgroup__stat.html">cgroup_stat</a> *stat)</td></tr>
<tr class="separator:gaf95587508fc15d74fd5ed0df58024be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba386d9db6cadc6ad85c2552f63447bb" id="r_gaba386d9db6cadc6ad85c2552f63447bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iterators.html#gaba386d9db6cadc6ad85c2552f63447bb">cgroup_read_stats_end</a> (void **handle)</td></tr>
<tr class="separator:gaba386d9db6cadc6ad85c2552f63447bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55d2eac2af703794651d344c073566f5" id="r_ga55d2eac2af703794651d344c073566f5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iterators.html#ga55d2eac2af703794651d344c073566f5">CG_VALUE_MAX</a>&#160;&#160;&#160;100</td></tr>
<tr class="separator:ga55d2eac2af703794651d344c073566f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">List all tasks in a group</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Use following functions to read <code>tasks</code> file of a group. </p>
</td></tr>
<tr class="memitem:gad194c8c62288dd37349ed947c91217d6" id="r_gad194c8c62288dd37349ed947c91217d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iterators.html#gad194c8c62288dd37349ed947c91217d6">cgroup_get_task_begin</a> (const char *cgrp, const char *controller, void **handle, pid_t *pid)</td></tr>
<tr class="separator:gad194c8c62288dd37349ed947c91217d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3a0364682b7449ddccfb0862bbb565e" id="r_gaf3a0364682b7449ddccfb0862bbb565e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iterators.html#gaf3a0364682b7449ddccfb0862bbb565e">cgroup_get_task_next</a> (void **handle, pid_t *pid)</td></tr>
<tr class="separator:gaf3a0364682b7449ddccfb0862bbb565e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb955e5f4da551268380b1271d478816" id="r_gaeb955e5f4da551268380b1271d478816"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iterators.html#gaeb955e5f4da551268380b1271d478816">cgroup_get_task_end</a> (void **handle)</td></tr>
<tr class="separator:gaeb955e5f4da551268380b1271d478816"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">List mounted controllers</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Use following function to list mounted controllers and to see, how they are mounted together in hierarchies. Use <a class="el" href="group__group__iterators.html#gad48ef653388ca6739a9b6bbb9d7da82e">cgroup_get_all_controller_begin()</a> (see later) to list all controllers, including those which are not mounted. </p>
</td></tr>
<tr class="memitem:ga5f9f21138f9b18912a16b21a45b53c44" id="r_ga5f9f21138f9b18912a16b21a45b53c44"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iterators.html#ga5f9f21138f9b18912a16b21a45b53c44">cgroup_get_controller_begin</a> (void **handle, struct <a class="el" href="structcgroup__mount__point.html">cgroup_mount_point</a> *info)</td></tr>
<tr class="separator:ga5f9f21138f9b18912a16b21a45b53c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga926b70423b6c087c21a14670cd23cd7d" id="r_ga926b70423b6c087c21a14670cd23cd7d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iterators.html#ga926b70423b6c087c21a14670cd23cd7d">cgroup_get_controller_next</a> (void **handle, struct <a class="el" href="structcgroup__mount__point.html">cgroup_mount_point</a> *info)</td></tr>
<tr class="separator:ga926b70423b6c087c21a14670cd23cd7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab485cda2bc9640bacbf61f1953ae750c" id="r_gab485cda2bc9640bacbf61f1953ae750c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iterators.html#gab485cda2bc9640bacbf61f1953ae750c">cgroup_get_controller_end</a> (void **handle)</td></tr>
<tr class="separator:gab485cda2bc9640bacbf61f1953ae750c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">List all controllers</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Use following functions to list all controllers, including those which are not mounted. The controllers are returned in the same order as in /proc/cgroups file, i.e. mostly random. </p>
</td></tr>
<tr class="memitem:gad48ef653388ca6739a9b6bbb9d7da82e" id="r_gad48ef653388ca6739a9b6bbb9d7da82e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iterators.html#gad48ef653388ca6739a9b6bbb9d7da82e">cgroup_get_all_controller_begin</a> (void **handle, struct <a class="el" href="structcontroller__data.html">controller_data</a> *info)</td></tr>
<tr class="separator:gad48ef653388ca6739a9b6bbb9d7da82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d98a04b29b1fe409db1114b7aa76809" id="r_ga3d98a04b29b1fe409db1114b7aa76809"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iterators.html#ga3d98a04b29b1fe409db1114b7aa76809">cgroup_get_all_controller_next</a> (void **handle, struct <a class="el" href="structcontroller__data.html">controller_data</a> *info)</td></tr>
<tr class="separator:ga3d98a04b29b1fe409db1114b7aa76809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c467d42a2c9a916a0edd339a6d7afc8" id="r_ga0c467d42a2c9a916a0edd339a6d7afc8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iterators.html#ga0c467d42a2c9a916a0edd339a6d7afc8">cgroup_get_all_controller_end</a> (void **handle)</td></tr>
<tr class="separator:ga0c467d42a2c9a916a0edd339a6d7afc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">List all mount points of a controller.</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Use following functions to list all mount points of a hierarchy with given controller. </p>
</td></tr>
<tr class="memitem:ga18a3c6fe7da42b9da96ce34dce1e31b8" id="r_ga18a3c6fe7da42b9da96ce34dce1e31b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iterators.html#ga18a3c6fe7da42b9da96ce34dce1e31b8">cgroup_get_subsys_mount_point_begin</a> (const char *controller, void **handle, char *path)</td></tr>
<tr class="separator:ga18a3c6fe7da42b9da96ce34dce1e31b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d66997158cb8a334317923ad94cc789" id="r_ga3d66997158cb8a334317923ad94cc789"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iterators.html#ga3d66997158cb8a334317923ad94cc789">cgroup_get_subsys_mount_point_next</a> (void **handle, char *path)</td></tr>
<tr class="separator:ga3d66997158cb8a334317923ad94cc789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c9b0f1921c205bd25bfc6c1d20486eb" id="r_ga9c9b0f1921c205bd25bfc6c1d20486eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iterators.html#ga9c9b0f1921c205bd25bfc6c1d20486eb">cgroup_get_subsys_mount_point_end</a> (void **handle)</td></tr>
<tr class="separator:ga9c9b0f1921c205bd25bfc6c1d20486eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>So-called iterators are a code pattern to retrieve various data from libcgroup in distinct chunks, for example when an application needs to read list of groups in a hierarchy, it uses iterator to get one group at a time. Iterator is opaque to the application, the application sees only <code>void* handle</code> pointer, which is managed internally by <code>libcgroup</code>. Each iterator provides at least these functions:</p><ul>
<li><code>int <em>iterator_name</em>_begin(void **handle, my_type *item)</code><ul>
<li>Initialize the iterator, store pointer to it into the <code>handle</code>.</li>
<li>Return the first element in the iterator, let's say it's <code>my_type</code>.</li>
<li>Return <code>0</code>, if the operation succeeded.</li>
<li>Return <a class="el" href="group__group__errors.html#gga06fc87d81c62e9abb8790b6e5713c55ba2724c2f0af0d3e3cea66027f6bf2e436">ECGEOF</a>, if the operation succeeded, but the iterator is empty. The value of <code>item</code> is undefined in this case.</li>
<li>Return any other error code on error.</li>
</ul>
</li>
<li><code>int <em>iterator_name</em>_next(void **handle, my_type *item)</code><ul>
<li>Advance to next element in the iterator and return it.</li>
<li>Return <code>0</code>, if the operation succeeded.</li>
<li>Return <a class="el" href="group__group__errors.html#gga06fc87d81c62e9abb8790b6e5713c55ba2724c2f0af0d3e3cea66027f6bf2e436">ECGEOF</a>, if there is no item to advance to, i.e. the iterator is already at its end. The value of <code>item</code> is undefined in this case.</li>
<li>Return any other error code on error.</li>
</ul>
</li>
<li><p class="startli"><code>void <em>iterator_name</em>_end(void **handle)</code></p><ul>
<li>Free any data associated with the iterator. This function must be called even when <code><em>iterator_name</em>_begin()</code> fails.</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000011">Todo:</a></b></dt><dd>not all iterators follow this pattern, e.g. <a class="el" href="group__group__iterators.html#ga7b19f10c06abb96d8c8ae88a04888a68">cgroup_walk_tree_begin()</a> can result both in a state that <a class="el" href="group__group__iterators.html#ga09a70990837a58e506a264f8c50d4cde">cgroup_walk_tree_end()</a> is not needed and will SIGSEGV and in a state that <a class="el" href="group__group__iterators.html#ga09a70990837a58e506a264f8c50d4cde">cgroup_walk_tree_end()</a> is needed to free allocated memory. Complete review is needed! </dd></dl>
<dl class="section user"><dt>Example of iterator usage:</dt><dd><div class="fragment"><div class="line"><span class="keywordtype">void</span> *handle; <span class="comment">// our iterator handle</span></div>
<div class="line">my_type item; <span class="comment">// the data returned by the iterator</span></div>
<div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">ret = iterator_name_begin(&amp;handle, &amp;item);</div>
<div class="line"><span class="keywordflow">while</span> (ret == 0) {</div>
<div class="line"> <span class="comment">// process the item here</span></div>
<div class="line"> ret = iterator_name_begin(&amp;handle, &amp;item);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (ret != <a class="code hl_enumvalue" href="group__group__errors.html#gga06fc87d81c62e9abb8790b6e5713c55ba2724c2f0af0d3e3cea66027f6bf2e436">ECGEOF</a>) {</div>
<div class="line"> <span class="comment">// process the error here</span></div>
<div class="line">}</div>
<div class="line">iterator_name_end(&amp;handle);</div>
<div class="ttc" id="agroup__group__errors_html_gga06fc87d81c62e9abb8790b6e5713c55ba2724c2f0af0d3e3cea66027f6bf2e436"><div class="ttname"><a href="group__group__errors.html#gga06fc87d81c62e9abb8790b6e5713c55ba2724c2f0af0d3e3cea66027f6bf2e436">ECGEOF</a></div><div class="ttdeci">@ ECGEOF</div><div class="ttdef"><b>Definition</b> error.h:68</div></div>
</div><!-- fragment --> </dd></dl>
</li>
</ul>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga55d2eac2af703794651d344c073566f5" name="ga55d2eac2af703794651d344c073566f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55d2eac2af703794651d344c073566f5">&#9670;&#160;</a></span>CG_VALUE_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CG_VALUE_MAX&#160;&#160;&#160;100</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum length of a value in stats file. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga608b4aa32e2db58fed34771a6a272444" name="ga608b4aa32e2db58fed34771a6a272444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga608b4aa32e2db58fed34771a6a272444">&#9670;&#160;</a></span>cgroup_file_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__iterators.html#ga608b4aa32e2db58fed34771a6a272444">cgroup_file_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of returned entity. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga608b4aa32e2db58fed34771a6a272444ad925cc45f1b34fe80e14fc6b05269740" name="gga608b4aa32e2db58fed34771a6a272444ad925cc45f1b34fe80e14fc6b05269740"></a>CGROUP_FILE_TYPE_FILE&#160;</td><td class="fielddoc"><p>File. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga608b4aa32e2db58fed34771a6a272444a5418798fc4bf9634429c6af167a0e7c3" name="gga608b4aa32e2db58fed34771a6a272444a5418798fc4bf9634429c6af167a0e7c3"></a>CGROUP_FILE_TYPE_DIR&#160;</td><td class="fielddoc"><p>Directory. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga608b4aa32e2db58fed34771a6a272444a24e202c59f318e63ad8cafcc1b4b102b" name="gga608b4aa32e2db58fed34771a6a272444a24e202c59f318e63ad8cafcc1b4b102b"></a>CGROUP_FILE_TYPE_OTHER&#160;</td><td class="fielddoc"><p>Directory. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000013">Todo:</a></b></dt><dd>really? </dd></dl>
</td></tr>
</table>

</div>
</div>
<a id="ga29a572cbc0c07e2b02dfa0f1ac0067d3" name="ga29a572cbc0c07e2b02dfa0f1ac0067d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29a572cbc0c07e2b02dfa0f1ac0067d3">&#9670;&#160;</a></span>cgroup_walk_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__iterators.html#ga29a572cbc0c07e2b02dfa0f1ac0067d3">cgroup_walk_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of the walk. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga29a572cbc0c07e2b02dfa0f1ac0067d3af865296e6a0e55cff574fbb132b9f913" name="gga29a572cbc0c07e2b02dfa0f1ac0067d3af865296e6a0e55cff574fbb132b9f913"></a>CGROUP_WALK_TYPE_PRE_DIR&#160;</td><td class="fielddoc"><p>Pre-order directory walk, return a directory first and then its subdirectories. E.g. directories would be returned in this order: </p><div class="fragment"><div class="line">/</div>
<div class="line">/group</div>
<div class="line">/group/subgroup1</div>
<div class="line">/group/subgroup1/subsubgroup</div>
<div class="line">/group/subgroup2</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="gga29a572cbc0c07e2b02dfa0f1ac0067d3abf3c31227768960bd6622d2562aae3e1" name="gga29a572cbc0c07e2b02dfa0f1ac0067d3abf3c31227768960bd6622d2562aae3e1"></a>CGROUP_WALK_TYPE_POST_DIR&#160;</td><td class="fielddoc"><p>Post-order directory walk, return subdirectories of a directory first and then the directory itself. E.g. directories would be returned in this order: </p><div class="fragment"><div class="line">/group/subgroup1/subsubgroup</div>
<div class="line">/group/subgroup1</div>
<div class="line">/group/subgroup2</div>
<div class="line">/group</div>
<div class="line">/</div>
</div><!-- fragment --> </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad48ef653388ca6739a9b6bbb9d7da82e" name="gad48ef653388ca6739a9b6bbb9d7da82e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad48ef653388ca6739a9b6bbb9d7da82e">&#9670;&#160;</a></span>cgroup_get_all_controller_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_get_all_controller_begin </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcontroller__data.html">controller_data</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the first of controllers from /proc/cgroups. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle to be used for iteration. </td></tr>
    <tr><td class="paramname">info</td><td>The structure which will be filled with controller data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0c467d42a2c9a916a0edd339a6d7afc8" name="ga0c467d42a2c9a916a0edd339a6d7afc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c467d42a2c9a916a0edd339a6d7afc8">&#9670;&#160;</a></span>cgroup_get_all_controller_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_get_all_controller_end </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release the iterator </p>

</div>
</div>
<a id="ga3d98a04b29b1fe409db1114b7aa76809" name="ga3d98a04b29b1fe409db1114b7aa76809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d98a04b29b1fe409db1114b7aa76809">&#9670;&#160;</a></span>cgroup_get_all_controller_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_get_all_controller_next </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcontroller__data.html">controller_data</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read next controllers from /proc/cgroups. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle to be used for iteration. </td></tr>
    <tr><td class="paramname">info</td><td>The structure which will be filled with controller data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5f9f21138f9b18912a16b21a45b53c44" name="ga5f9f21138f9b18912a16b21a45b53c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f9f21138f9b18912a16b21a45b53c44">&#9670;&#160;</a></span>cgroup_get_controller_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_get_controller_begin </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcgroup__mount__point.html">cgroup_mount_point</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the mount table to give a list where each controller is mounted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle to be used for iteration. </td></tr>
    <tr><td class="paramname">info</td><td>The variable where the path to the controller is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__group__errors.html#gga06fc87d81c62e9abb8790b6e5713c55ba2724c2f0af0d3e3cea66027f6bf2e436">ECGEOF</a> when no controllers are mounted. </dd></dl>

</div>
</div>
<a id="gab485cda2bc9640bacbf61f1953ae750c" name="gab485cda2bc9640bacbf61f1953ae750c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab485cda2bc9640bacbf61f1953ae750c">&#9670;&#160;</a></span>cgroup_get_controller_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_get_controller_end </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release the iterator. </p>

</div>
</div>
<a id="ga926b70423b6c087c21a14670cd23cd7d" name="ga926b70423b6c087c21a14670cd23cd7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga926b70423b6c087c21a14670cd23cd7d">&#9670;&#160;</a></span>cgroup_get_controller_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_get_controller_next </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcgroup__mount__point.html">cgroup_mount_point</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the next mounted controller. While walking through the mount table, the controllers are returned in order of their mount points, i.e. controllers mounted together in one hierarchy are returned next to each other. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle to be used for iteration. </td></tr>
    <tr><td class="paramname">info</td><td>The variable where the path to the controller is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__group__errors.html#gga06fc87d81c62e9abb8790b6e5713c55ba2724c2f0af0d3e3cea66027f6bf2e436">ECGEOF</a> when all controllers were already returned. </dd></dl>

</div>
</div>
<a id="ga18a3c6fe7da42b9da96ce34dce1e31b8" name="ga18a3c6fe7da42b9da96ce34dce1e31b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18a3c6fe7da42b9da96ce34dce1e31b8">&#9670;&#160;</a></span>cgroup_get_subsys_mount_point_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_get_subsys_mount_point_begin </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>controller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the first mount point of the hierarchy with given controller. The first is the same as the mount point returned by cgroup_get_subsys_mount_point(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle to be used for iteration. </td></tr>
    <tr><td class="paramname">controller</td><td>The controller name. </td></tr>
    <tr><td class="paramname">path</td><td>Buffer to fill the path into. The buffer must be at least FILENAME_MAX characters long. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9c9b0f1921c205bd25bfc6c1d20486eb" name="ga9c9b0f1921c205bd25bfc6c1d20486eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c9b0f1921c205bd25bfc6c1d20486eb">&#9670;&#160;</a></span>cgroup_get_subsys_mount_point_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_get_subsys_mount_point_end </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release the iterator. </p>

</div>
</div>
<a id="ga3d66997158cb8a334317923ad94cc789" name="ga3d66997158cb8a334317923ad94cc789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d66997158cb8a334317923ad94cc789">&#9670;&#160;</a></span>cgroup_get_subsys_mount_point_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_get_subsys_mount_point_next </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read next mount point of the hierarchy with given controller. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle to be used for iteration. </td></tr>
    <tr><td class="paramname">path</td><td>Buffer to fill the path into. The buffer must be at least FILENAME_MAX characters long. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad194c8c62288dd37349ed947c91217d6" name="gad194c8c62288dd37349ed947c91217d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad194c8c62288dd37349ed947c91217d6">&#9670;&#160;</a></span>cgroup_get_task_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_get_task_begin </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cgrp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>controller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pid_t *&#160;</td>
          <td class="paramname"><em>pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the tasks file to get the list of tasks in a cgroup. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cgrp</td><td>Name of the cgroup. </td></tr>
    <tr><td class="paramname">controller</td><td>Name of the cgroup subsystem. </td></tr>
    <tr><td class="paramname">handle</td><td>The handle to be used in the iteration. </td></tr>
    <tr><td class="paramname">pid</td><td>The pid read from the tasks file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__group__errors.html#gga06fc87d81c62e9abb8790b6e5713c55ba2724c2f0af0d3e3cea66027f6bf2e436">ECGEOF</a> when the group does not contain any tasks. </dd></dl>

</div>
</div>
<a id="gaeb955e5f4da551268380b1271d478816" name="gaeb955e5f4da551268380b1271d478816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb955e5f4da551268380b1271d478816">&#9670;&#160;</a></span>cgroup_get_task_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_get_task_end </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release the iterator. </p>

</div>
</div>
<a id="gaf3a0364682b7449ddccfb0862bbb565e" name="gaf3a0364682b7449ddccfb0862bbb565e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3a0364682b7449ddccfb0862bbb565e">&#9670;&#160;</a></span>cgroup_get_task_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_get_task_next </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pid_t *&#160;</td>
          <td class="paramname"><em>pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the next task value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle used for iterating. </td></tr>
    <tr><td class="paramname">pid</td><td>The variable where the value will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__group__errors.html#gga06fc87d81c62e9abb8790b6e5713c55ba2724c2f0af0d3e3cea66027f6bf2e436">ECGEOF</a> when the iterator finishes getting the list of tasks. </dd></dl>

</div>
</div>
<a id="ga1138e47f124f0f634586db5e0c4ae5de" name="ga1138e47f124f0f634586db5e0c4ae5de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1138e47f124f0f634586db5e0c4ae5de">&#9670;&#160;</a></span>cgroup_read_stats_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_read_stats_begin </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>controller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcgroup__stat.html">cgroup_stat</a> *&#160;</td>
          <td class="paramname"><em>stat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the statistics values (= <code>stats</code> parameter) for the specified controller and control group. One line is returned per <a class="el" href="group__group__iterators.html#ga1138e47f124f0f634586db5e0c4ae5de">cgroup_read_stats_begin()</a> and <a class="el" href="group__group__iterators.html#gaf95587508fc15d74fd5ed0df58024be7">cgroup_read_stats_next()</a> call. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">controller</td><td>Name of the controller for which stats are requested. </td></tr>
    <tr><td class="paramname">path</td><td>The path to control group, relative to hierarchy root. </td></tr>
    <tr><td class="paramname">handle</td><td>The handle to be used during iteration. </td></tr>
    <tr><td class="paramname">stat</td><td>Returned first item in the stats file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__group__errors.html#gga06fc87d81c62e9abb8790b6e5713c55ba2724c2f0af0d3e3cea66027f6bf2e436">ECGEOF</a> when the stats file is empty. </dd></dl>

</div>
</div>
<a id="gaba386d9db6cadc6ad85c2552f63447bb" name="gaba386d9db6cadc6ad85c2552f63447bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba386d9db6cadc6ad85c2552f63447bb">&#9670;&#160;</a></span>cgroup_read_stats_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_read_stats_end </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release the iterator. </p>

</div>
</div>
<a id="gaf95587508fc15d74fd5ed0df58024be7" name="gaf95587508fc15d74fd5ed0df58024be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf95587508fc15d74fd5ed0df58024be7">&#9670;&#160;</a></span>cgroup_read_stats_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_read_stats_next </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcgroup__stat.html">cgroup_stat</a> *&#160;</td>
          <td class="paramname"><em>stat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the next stat value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle to be used during iteration. </td></tr>
    <tr><td class="paramname">stat</td><td>Returned next item in the stats file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__group__errors.html#gga06fc87d81c62e9abb8790b6e5713c55ba2724c2f0af0d3e3cea66027f6bf2e436">ECGEOF</a> when the iterator finishes getting the list of stats. </dd></dl>

</div>
</div>
<a id="ga9378ee0f1f6e65900df8e25b3d7ce236" name="ga9378ee0f1f6e65900df8e25b3d7ce236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9378ee0f1f6e65900df8e25b3d7ce236">&#9670;&#160;</a></span>cgroup_read_value_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_read_value_begin </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>controller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the value of the given variable for the specified controller and control group. The value is read up to newline character or at most max-1 characters, whichever comes first (i.e. similar to fgets()). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">controller</td><td>Name of the controller for which stats are requested. </td></tr>
    <tr><td class="paramname">path</td><td>The path to control group, relative to hierarchy root. </td></tr>
    <tr><td class="paramname">name</td><td>is variable name. </td></tr>
    <tr><td class="paramname">handle</td><td>The handle to be used during iteration. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer to read the value into. The buffer is always zero-terminated. </td></tr>
    <tr><td class="paramname">max</td><td>Maximal length of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__group__errors.html#gga06fc87d81c62e9abb8790b6e5713c55ba2724c2f0af0d3e3cea66027f6bf2e436">ECGEOF</a> when the stats file is empty. </dd></dl>

</div>
</div>
<a id="gad348f041e283860cbf6bcea567e23a21" name="gad348f041e283860cbf6bcea567e23a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad348f041e283860cbf6bcea567e23a21">&#9670;&#160;</a></span>cgroup_read_value_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_read_value_end </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release the iterator. </p>

</div>
</div>
<a id="gaced2fe331f19d599a3270db2440847cc" name="gaced2fe331f19d599a3270db2440847cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaced2fe331f19d599a3270db2440847cc">&#9670;&#160;</a></span>cgroup_read_value_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_read_value_next </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the next string from the given variable handle which is generated by <a class="el" href="group__group__iterators.html#ga1138e47f124f0f634586db5e0c4ae5de">cgroup_read_stats_begin()</a> function. the value is read up to newline character or at most max-1 characters, whichever comes first (i.e. similar to fgets()) per <a class="el" href="group__group__iterators.html#gaf95587508fc15d74fd5ed0df58024be7">cgroup_read_stats_next()</a> call </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle to be used during iteration. </td></tr>
    <tr><td class="paramname">data</td><td>returned the string. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer to read the value into. The buffer is always zero-terminated. </td></tr>
    <tr><td class="paramname">max</td><td>Maximal length of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__group__errors.html#gga06fc87d81c62e9abb8790b6e5713c55ba2724c2f0af0d3e3cea66027f6bf2e436">ECGEOF</a> when the iterator finishes getting the list of stats. </dd></dl>

</div>
</div>
<a id="ga7b19f10c06abb96d8c8ae88a04888a68" name="ga7b19f10c06abb96d8c8ae88a04888a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b19f10c06abb96d8c8ae88a04888a68">&#9670;&#160;</a></span>cgroup_walk_tree_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_walk_tree_begin </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>controller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>base_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcgroup__file__info.html">cgroup_file_info</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>base_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Walk through the directory tree for the specified controller. The directory representing <code>base_path</code> is returned in <code>info</code>. Use <a class="el" href="group__group__iterators.html#ga645ec7a6206dffb32667e7a0e148edc8">cgroup_walk_tree_set_flags()</a> to specify, in which order should be next directories returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">controller</td><td>Name of the controller, for which we want to walk the directory tree. </td></tr>
    <tr><td class="paramname">base_path</td><td>Begin walking from this path. Use "/" to walk through full hierarchy. </td></tr>
    <tr><td class="paramname">depth</td><td>The maximum depth to which the function should walk, 0 implies all the way down. </td></tr>
    <tr><td class="paramname">handle</td><td>The handle to be used during iteration. </td></tr>
    <tr><td class="paramname">info</td><td>The info filled and returned about directory information. </td></tr>
    <tr><td class="paramname">base_level</td><td>Opaque integer which you must pass to subsequent cgroup_walk_tree_next. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000012">Todo:</a></b></dt><dd>why base_level is not hidden in **handle? </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__group__errors.html#gga06fc87d81c62e9abb8790b6e5713c55ba2724c2f0af0d3e3cea66027f6bf2e436">ECGEOF</a> when there is no node. </dd></dl>

</div>
</div>
<a id="ga09a70990837a58e506a264f8c50d4cde" name="ga09a70990837a58e506a264f8c50d4cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09a70990837a58e506a264f8c50d4cde">&#9670;&#160;</a></span>cgroup_walk_tree_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_walk_tree_end </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release the iterator. </p>

</div>
</div>
<a id="ga527f5499b0aa04d325074435baebdff1" name="ga527f5499b0aa04d325074435baebdff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga527f5499b0aa04d325074435baebdff1">&#9670;&#160;</a></span>cgroup_walk_tree_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_walk_tree_next </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcgroup__file__info.html">cgroup_file_info</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the next directory in the walk. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth</td><td>The maximum depth to which the function should walk, 0 implies all the way down. </td></tr>
    <tr><td class="paramname">handle</td><td>The handle to be used during iteration. </td></tr>
    <tr><td class="paramname">info</td><td>The info filled and returned about the next directory. </td></tr>
    <tr><td class="paramname">base_level</td><td>Value of base_level returned by <a class="el" href="group__group__iterators.html#ga7b19f10c06abb96d8c8ae88a04888a68">cgroup_walk_tree_begin()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__group__errors.html#gga06fc87d81c62e9abb8790b6e5713c55ba2724c2f0af0d3e3cea66027f6bf2e436">ECGEOF</a> when we are done walking through the nodes. </dd></dl>

</div>
</div>
<a id="ga645ec7a6206dffb32667e7a0e148edc8" name="ga645ec7a6206dffb32667e7a0e148edc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga645ec7a6206dffb32667e7a0e148edc8">&#9670;&#160;</a></span>cgroup_walk_tree_set_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cgroup_walk_tree_set_flags </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the flags for walk_tree. Currently available flags are in <a class="el" href="group__group__iterators.html#ga29a572cbc0c07e2b02dfa0f1ac0067d3">cgroup_walk_type</a> enum. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle of the iterator. </td></tr>
    <tr><td class="paramname">flags</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
